<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- prevent zoom-on-focus on iOS + keep layout snug -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>EQ Visit Tracker</title>
  <meta name="theme-color" content="#145AFF" />
  <link rel="manifest" href="manifest.webmanifest">
  <style>
    :root {
      --brand:#145AFF; --bg:#f7f9fc; --card:#fff; --muted:#6b7280;
      --ok:#10b981; --warn:#f59e0b; --bad:#ef4444; --line:#e5e7eb;
    }
    * { box-sizing:border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:var(--bg); color:#111827; }
    header { position:sticky; top:0; z-index:10; background:#fff; border-bottom:1px solid var(--line);
             padding:.5rem 1rem; display:flex; align-items:center; gap:.75rem; flex-wrap:wrap; }
    header h1 { font-size:1.1rem; margin:0; color:var(--brand); }
    .grow { flex:1; min-width:.5rem; }
    .card { background:var(--card); border:1px solid var(--line); border-radius:14px; padding:1rem; }
    .toolbar { display:flex; gap:.5rem; flex-wrap:wrap; align-items:center; }
    .toggle-inactive { display:flex; align-items:center; gap:.35rem; margin-left:.5rem; justify-content:flex-start; }
    .toggle-inactive span { white-space:nowrap; display:inline-flex; align-items:center; }
    .history-filter { display:flex; gap:.5rem; flex-wrap:wrap; align-items:center; }
    .history-filter label { display:flex; align-items:center; gap:.35rem; font-size:.85rem; color:#374151; }
    .history-filter label .input { width:11rem; }
    .history-filter .btn { white-space:nowrap; }
    .btn { background:var(--brand); color:#fff; border:0; padding:.55rem .9rem; border-radius:12px; cursor:pointer; }
    .btn.outline { background:transparent; color:var(--brand); border:1px solid var(--brand); }
    .btn.light { background:#e5edff; color:var(--brand); }
    .btn.danger { background:var(--bad); }
    .input, select, textarea { padding:.55rem .65rem; border:1px solid var(--line); border-radius:10px; background:#fff; font-size:16px; } /* 16px to prevent iOS zoom */
    .grid { display:grid; grid-template-columns:repeat(auto-fill, minmax(280px, 1fr)); gap:.75rem; }
    .pill { display:inline-block; padding:.2rem .5rem; border-radius:999px; font-size:.75rem; border:1px solid var(--line); background:#fff; }
    .pill.ok{ border-color:var(--ok); color:var(--ok); } .pill.warn{ border-color:var(--warn); color:var(--warn); }
    .pill.bad{ border-color:var(--bad); color:var(--bad); } .pill.gray{ border-color:#9ca3af; color:#6b7280; }
    nav { display:flex; gap:.5rem; }
    main { padding:1rem; max-width:1100px; margin:0 auto; display:grid; gap:1rem; }
    .muted { color:var(--muted); }
    .subtle { font-size:.85rem; color:#6b7280; }
    table { width:100%; border-collapse:collapse; }
    th, td { padding:.5rem; border-bottom:1px solid var(--line); text-align:left; }
    .history-preview-row { display:none; background:#f9fafb; }
    .history-preview-row.open { display:table-row; }
    .history-preview-row td { padding:0; border-bottom:1px solid var(--line); background:#f9fafb; }
    .history-preview { padding:.75rem 1rem; display:flex; flex-direction:column; gap:.6rem; }
    .history-preview-header { display:flex; flex-wrap:wrap; gap:.5rem; justify-content:space-between; align-items:center; }
    .history-preview-summary { font-size:.85rem; color:#374151; }
    .history-preview-range { font-size:.8rem; color:var(--muted); }
    .history-preview-list { list-style:none; margin:0; padding:0; display:flex; flex-direction:column; gap:.5rem; }
    .history-preview-item { display:flex; flex-direction:column; gap:.25rem; padding:.55rem .65rem; border-radius:10px; border:1px solid var(--line); background:#fff; }
    .history-preview-item-header { display:flex; gap:.5rem; flex-wrap:wrap; align-items:center; font-weight:600; color:#1f2937; }
    .history-preview-meta { display:flex; gap:.5rem; flex-wrap:wrap; font-size:.8rem; color:var(--muted); }
    .history-preview-notes { font-size:.85rem; color:#374151; white-space:pre-wrap; }
    .history-preview-empty { font-size:.9rem; color:var(--muted); font-style:italic; }
    .history-preview-actions { display:flex; flex-wrap:wrap; gap:.5rem; }
    .history-overlay { position:fixed; inset:0; background:rgba(15,23,42,.45); display:flex; align-items:center; justify-content:center; padding:1rem; z-index:45; opacity:0; pointer-events:none; transition:opacity .2s ease; }
    .history-overlay.open { opacity:1; pointer-events:auto; }
    .history-modal { background:#fff; width:min(520px,100%); max-height:90vh; border-radius:16px; padding:1.25rem; box-shadow:0 20px 40px rgba(15,23,42,.2); border:1px solid rgba(15,23,42,.08); display:flex; flex-direction:column; gap:1rem; overflow:hidden; }
    .history-modal-header { display:flex; gap:.75rem; justify-content:space-between; align-items:flex-start; }
    .history-modal-title { font-size:1.05rem; font-weight:600; color:#1f2937; }
    .history-modal-range { font-size:.85rem; color:var(--muted); }
    .history-modal-body { flex:1; overflow:auto; display:flex; flex-direction:column; gap:.75rem; }
    .history-modal-item { border:1px solid var(--line); border-radius:12px; padding:.75rem; display:flex; flex-direction:column; gap:.35rem; background:#f9fafb; }
    .history-modal-item-header { display:flex; flex-wrap:wrap; gap:.5rem; align-items:center; justify-content:space-between; font-weight:600; color:#1f2937; }
    .history-modal-item-meta { font-size:.85rem; color:var(--muted); display:flex; gap:.5rem; flex-wrap:wrap; }
    .history-modal-item-notes { font-size:.9rem; color:#1f2937; white-space:pre-wrap; }
    .history-modal-footer { display:flex; justify-content:space-between; align-items:center; gap:.75rem; flex-wrap:wrap; }
    .history-modal-page { font-size:.85rem; color:#6b7280; }
    .section-title { margin:.25rem 0 .25rem; font-size:.95rem; color:#374151; }
    .thbtn { background:transparent; border:0; cursor:pointer; font:inherit; padding:0; color:#111827; }
    .thbtn span { margin-left:.25rem; color:#6b7280; }
    tr.inactive { opacity:.55; }
    td.namecell { display:flex; align-items:center; gap:.5rem; font-weight:600; }
    #view-elders td.actions { display:flex; gap:.35rem; flex-wrap:wrap; align-items:center; }
    #authBox { display:flex; gap:.5rem; align-items:center; margin-left:auto; flex-wrap:wrap; }
    #currentUser { max-width:45vw; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; color:#374151; }

    /* Mobile cards for directory */
    @media (max-width:640px){
      header { gap:.5rem; padding:.5rem .75rem; }
      nav { width:100%; order:1; flex-wrap:wrap; gap:.5rem; }
      #authBox { width:100%; order:2; justify-content:flex-start; }
      #authBox input,
      #authBox button { flex:1 1 100%; }
      .btn { padding:.45rem .7rem; border-radius:10px; }
      .grid { grid-template-columns:1fr; }
      .card { padding:.75rem; }
      .toolbar { gap:.5rem; flex-direction:column; align-items:stretch; }
      .toolbar input, .toolbar select, .toolbar button { width:100%; }
      #view-elders .toolbar .toggle-inactive { width:auto; margin:0; justify-content:flex-start; align-self:flex-start; }
      #view-elders .toolbar .toggle-inactive span { white-space:normal; }
      #view-elders table thead { display:none; }
      #view-elders table, #view-elders tbody, #view-elders tr, #view-elders td { display:block; width:100%; }
      #view-elders tbody tr { background:#fff; border:1px solid var(--line); border-radius:12px; padding:.75rem; margin:.5rem 0; display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:.5rem .75rem; align-items:start; }
      #view-elders tbody td { border:0; padding:0; display:flex; flex-direction:column; gap:.15rem; align-items:flex-start; }
      #view-elders tbody td::before { content:attr(data-label); font-size:.7rem; letter-spacing:.05em; text-transform:uppercase; color:var(--muted); }
      #view-elders tbody td.namecell { grid-column:1 / -1; font-size:1.05rem; padding-bottom:0; }
      #view-elders tbody td.namecell::before { display:none; }
      #view-elders tbody td.actions { grid-column:1 / -1; width:100%; }
      #view-elders tbody td.actions::before { display:none; }
      #view-elders tbody td.actions { display:flex; flex-wrap:wrap; gap:.4rem; }
      #view-elders tbody td.actions .btn { flex:1 1 calc(50% - .3rem); min-width:7rem; }
      #view-elders tbody td.actions .btn.danger { flex-basis:100%; }
      .history-filter { width:100%; justify-content:flex-start; }
      .history-filter label { width:100%; justify-content:space-between; }
      .history-filter label .input { width:100%; }
      .history-filter .btn { width:100%; }
      #view-elders tbody tr.history-preview-row { display:none; padding:0; margin:0; border:0; }
      #view-elders tbody tr.history-preview-row.open { display:block; background:#f9fafb; }
      #view-elders tbody tr.history-preview-row td { padding:0; }
      #view-elders tbody tr.history-preview-row td::before { display:none; }
      .history-preview { padding:.75rem; }
      #currentUser { max-width:60vw; }
      .schedule-header { flex-direction:column; align-items:stretch; }
      .schedule-header-actions { width:100%; justify-content:space-between; }
      .schedule-row-actions { justify-content:flex-start; width:100%; }
    }

    /* “two-up” area on Next Up */
    .twoup { display:grid; grid-template-columns:1fr 1fr; gap:.75rem; }
    @media (max-width:800px){ .twoup { grid-template-columns:1fr; } }
    .list { display:flex; flex-direction:column; gap:.5rem; }
    .row { display:flex; gap:.5rem; align-items:center; justify-content:space-between; }
    .row .who { font-weight:600; }
    .schedule-header { display:flex; flex-wrap:wrap; align-items:center; justify-content:space-between; gap:.5rem; margin-bottom:.5rem; }
    .schedule-header .btn { white-space:nowrap; }
    .week-label { display:flex; flex-direction:column; gap:.1rem; min-width:0; }
    .week-label div:first-child { font-weight:600; }
    .schedule-header-actions { display:flex; gap:.5rem; flex-wrap:wrap; align-items:center; }
    .schedule-row-actions { display:flex; gap:.5rem; flex-wrap:wrap; justify-content:flex-end; }
    .status-pill { display:inline-flex; align-items:center; gap:.35rem; padding:.2rem .6rem; border-radius:999px; font-size:.75rem; font-weight:600; border:1px solid transparent; }
    .status-pill.planned { background:#fff7ed; color:#9a3412; border-color:#fed7aa; }
    .status-pill.confirmed { background:#ecfdf5; color:#047857; border-color:#6ee7b7; }
    .status-pill.visited { background:#eff6ff; color:#1d4ed8; border-color:#bfdbfe; }
    .status-pill.neutral { background:#f3f4f6; color:#374151; border-color:#d1d5db; }
    .toast-host { position:fixed; top:1rem; left:50%; transform:translateX(-50%); display:flex; flex-direction:column; gap:.5rem;
      z-index:50; width:min(90vw,360px); pointer-events:none; }
    .toast { background:#fff; color:#111827; border-radius:12px; box-shadow:0 16px 32px rgba(15,23,42,.12);
      border:1px solid rgba(15,23,42,.08); padding:.75rem 1rem; display:flex; align-items:center; gap:.75rem;
      opacity:0; transform:translateY(-8px); transition:opacity .18s ease, transform .18s ease; pointer-events:auto; }
    .toast.show { opacity:1; transform:translateY(0); }
    .toast::before { content:''; display:inline-block; width:.6rem; height:.6rem; border-radius:999px; background:var(--brand); }
    .toast.success::before { background:var(--ok); }
    .toast.error::before { background:var(--bad); }
    .toast button.toast-close { margin-left:auto; background:none; border:0; color:inherit; cursor:pointer; padding:.25rem;
      font-size:1.1rem; line-height:1; display:flex; align-items:center; justify-content:center; border-radius:8px; }
    .toast button.toast-close:focus-visible { outline:2px solid var(--brand); outline-offset:2px; }
    .confirm-overlay { position:fixed; inset:0; background:rgba(15,23,42,.38); display:flex; align-items:center; justify-content:center;
      padding:1rem; z-index:40; opacity:0; pointer-events:none; transition:opacity .2s ease; }
    .confirm-overlay.open { opacity:1; pointer-events:auto; }
    .confirm-modal { background:#fff; width:min(360px,100%); border-radius:16px; padding:1.25rem; box-shadow:0 18px 40px rgba(15,23,42,.2);
      border:1px solid rgba(15,23,42,.08); display:flex; flex-direction:column; gap:1rem; }
    .confirm-message { font-size:.95rem; color:#1f2937; }
    .confirm-buttons { display:flex; justify-content:flex-end; gap:.5rem; flex-wrap:wrap; }
    .confirm-overlay button { min-width:0; }

    .import-status { margin-top:.75rem; padding:.75rem; border-radius:12px; border:1px solid transparent; display:none; font-size:.9rem; }
    .import-status.info { background:#eef2ff; color:#3730a3; border-color:#c7d2fe; }
    .import-status.success { background:#ecfdf5; color:#047857; border-color:#a7f3d0; }
    .import-status.error { background:#fef2f2; color:#b91c1c; border-color:#fecaca; }
    .import-status.warning { background:#fffbeb; color:#92400e; border-color:#fcd34d; }
    .import-preview { display:none; }
    .import-preview-summary { display:flex; flex-direction:column; gap:.25rem; font-size:.9rem; }
    .import-preview-details { display:flex; flex-direction:column; gap:.75rem; margin-top:.75rem; }
    .import-preview-section { border:1px solid var(--line); border-radius:12px; padding:.75rem; background:#f9fafb; }
    .import-preview-section.error { border-color:var(--bad); background:#fef2f2; }
    .import-preview-section-title { font-weight:600; margin-bottom:.35rem; }
    .import-preview-section table { width:100%; border-collapse:collapse; font-size:.85rem; }
    .import-preview-section th, .import-preview-section td { padding:.35rem .5rem; border-bottom:1px solid var(--line); text-align:left; vertical-align:top; }
    .import-preview-section tbody tr:last-child td { border-bottom:none; }
    .import-preview-empty { color:var(--muted); font-style:italic; }
    .import-preview-footer { display:flex; gap:.5rem; flex-wrap:wrap; margin-top:1rem; }
    .import-preview-footer .btn { flex:0 0 auto; }
    .import-error-list { margin:0; padding-left:1.25rem; font-size:.9rem; }
    .import-error-list li { margin:.25rem 0; }
    .import-error-list strong { color:var(--bad); }
    .import-preview-scroll { overflow:auto; max-height:240px; }
  </style>
</head>
<body>
  <div id="toastHost" class="toast-host" aria-live="polite" aria-atomic="true"></div>
  <div id="confirmOverlay" class="confirm-overlay" aria-hidden="true">
    <div class="confirm-modal" role="dialog" aria-modal="true" aria-labelledby="confirmMessage">
      <div id="confirmMessage" class="confirm-message"></div>
      <div class="confirm-buttons">
        <button type="button" class="btn outline" data-cancel>Cancel</button>
        <button type="button" class="btn" data-confirm>Confirm</button>
      </div>
    </div>
  </div>
  <div id="historyOverlay" class="history-overlay" aria-hidden="true">
    <div class="history-modal" role="dialog" aria-modal="true" aria-labelledby="historyModalTitle">
      <div class="history-modal-header">
        <div>
          <div id="historyModalTitle" class="history-modal-title"></div>
          <div id="historyModalRange" class="history-modal-range"></div>
        </div>
        <button type="button" class="btn light" id="historyModalClose">Close</button>
      </div>
      <div id="historyModalBody" class="history-modal-body"></div>
      <div class="history-modal-footer">
        <button type="button" class="btn outline" id="historyModalPrev">◀ Prev</button>
        <div id="historyModalPage" class="history-modal-page"></div>
        <button type="button" class="btn outline" id="historyModalNext">Next ▶</button>
      </div>
    </div>
  </div>
  <header class="card" style="border:none; border-radius:0">
    <h1>EQ Visit Tracker</h1>
    <nav>
      <button class="btn light" onclick="showView('next')">Next Up</button>
      <button class="btn light" onclick="showView('elders')">Directory</button>
      <button class="btn light" onclick="showView('log')">Log Visit</button>
      <button class="btn light" onclick="showView('import')">Import</button>
    </nav>
    <div class="grow"></div>
    <div id="authBox">
      <span id="currentUser" class="muted"></span>
      <input id="email" class="input" placeholder="Email" autocomplete="username">
      <input id="password" class="input" type="password" placeholder="Password" autocomplete="current-password">
      <button class="btn" id="signinBtn" onclick="signIn()">Sign in</button>
      <button class="btn outline" id="createBtn" onclick="create()">Create</button>
      <button class="btn danger" id="logoutBtn" onclick="signOut()" style="display:none">Sign out</button>
    </div>
  </header>

  <main>
    <!-- NEXT UP -->
    <section id="view-next" class="card" style="display:none">
      <!-- new: “recent texts” and “this week” -->
      <div class="twoup" style="margin-bottom:.5rem">
        <div class="card" style="padding:.75rem">
          <div class="section-title">Recently texted (last 10 days)</div>
          <div id="recentTexts" class="list"></div>
        </div>
        <div class="card" style="padding:.75rem">
          <div class="section-title">Scheduled visits</div>
          <div class="schedule-header">
            <button class="btn outline" id="weekPrevBtn">◀ Prev</button>
            <div class="week-label">
              <div id="scheduleWeekLabel"></div>
              <div id="scheduleWeekContext" class="subtle"></div>
            </div>
            <div class="schedule-header-actions">
              <button class="btn outline" id="weekTodayBtn">This week</button>
              <button class="btn outline" id="weekNextBtn">Next ▶</button>
            </div>
          </div>
          <div id="thisWeek" class="list"></div>
        </div>
      </div>

      <div class="toolbar">
        <input id="searchNext" class="input" placeholder="Search name/phone/email/address">
        <button class="btn outline" id="btnSearchNext">Search</button>
        <button class="btn outline" id="pickWeekBtn" onclick="pickThisWeek()">Pick next elder (for this week)</button>
        <div class="grow"></div>
        <span id="yearRemaining" class="muted"></span>
      </div>
      <div class="section-title">Top candidates</div>
      <div id="nextGrid" class="grid"></div>
    </section>

    <!-- DIRECTORY -->
    <section id="view-elders" class="card" style="display:none">
      <div class="toolbar">
        <input id="searchElders" class="input" placeholder="Search name/phone/address/email">
        <button class="btn outline" id="btnSearchElders">Search</button>
        <select id="sortSelect" class="input" title="Sort">
          <option value="name">First name</option>
          <option value="visited">Last visited</option>
          <option value="attempts">Attempts (recent first)</option>
          <option value="phone">Phone</option>
        </select>
        <button class="btn outline" onclick="addElderPrompt()">Quick add</button>
        <label class="toggle-inactive">
          <input type="checkbox" id="hideInactive" checked>
          <span>Hide inactive</span>
        </label>
        <div class="history-filter">
          <label for="historyStart">From
            <input type="date" id="historyStart" class="input" aria-label="Visit history start">
          </label>
          <label for="historyEnd">To
            <input type="date" id="historyEnd" class="input" aria-label="Visit history end">
          </label>
          <button type="button" class="btn light" id="historyClear">Clear range</button>
        </div>
        <div class="grow"></div>
        <span id="eldersCount" class="muted"></span>
      </div>

      <table>
        <thead>
          <tr>
            <th><button class="thbtn" onclick="setSort('name')">Name <span id="sort-name"></span></button></th>
            <th><button class="thbtn" onclick="setSort('phone')">Phone <span id="sort-phone"></span></button></th>
            <th><button class="thbtn" onclick="setSort('visited')">Last visited <span id="sort-visited"></span></button></th>
            <th><button class="thbtn" onclick="setSort('attempts')">Attempts <span id="sort-attempts"></span></button></th>
            <th>Asked</th>
            <th>Status</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody id="eldersTbody"></tbody>
      </table>
    </section>

    <!-- LOG -->
    <section id="view-log" class="card" style="display:none">
      <div class="toolbar">
        <select id="logElderSelect"></select>
        <input type="date" id="logDate" class="input">
        <select id="logOutcome" class="input">
          <option>Visited</option>
          <option>Scheduled</option>
          <option>No answer</option>
          <option>Reschedule</option>
        </select>
        <input id="logVisitors" class="input" placeholder="Visitors (e.g., Presidency)">
      </div>
      <textarea id="logNotes" class="input" placeholder="Notes" style="width:100%; height:90px; margin-top:.5rem"></textarea>
      <div style="margin-top:.5rem">
        <button class="btn" onclick="saveVisit()">Save visit</button>
      </div>
    </section>

    <!-- IMPORT / EXPORT -->
    <section id="view-import" class="card" style="display:none">
      <div class="section-title">Import Elders CSV (see template)</div>
      <input type="file" id="csvFile" accept=".csv">
      <div style="margin-top:.5rem; display:flex; gap:.5rem; flex-wrap:wrap">
        <button class="btn" onclick="importCsv()">Preview import</button>
        <button class="btn outline" onclick="exportBackup()">Export backup (JSON)</button>
        <button class="btn outline" onclick="exportCsv()">Export CSV</button>
        <button class="btn danger" onclick="fixDuplicates()">Fix duplicates</button>
        <a class="btn outline" href="elders_template.csv" download>Download template</a>
      </div>
      <p class="muted" style="margin-top:.5rem">
        Preview the changes before applying. Import remains idempotent (safe to run multiple times). Missing records become <b>inactive</b> and visit history is preserved.
      </p>
      <div id="importStatus" class="import-status" role="status" aria-live="polite" aria-hidden="true"></div>
      <div id="importPreviewCard" class="card import-preview" style="display:none; margin-top:1rem" aria-hidden="true">
        <div class="section-title" style="margin-top:0">Import preview</div>
        <div id="importPreviewSummary" class="import-preview-summary"></div>
        <div id="importPreviewDetails" class="import-preview-details"></div>
        <div class="import-preview-footer">
          <button class="btn" id="applyImportBtn" onclick="applyImportChanges()" disabled>Apply changes</button>
          <button class="btn outline" id="downloadImportErrorsBtn" onclick="downloadImportErrors()" style="display:none">Download error report</button>
        </div>
      </div>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <script type="module">
    /* ---------- Firebase ---------- */
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
    import {
      getAuth, onAuthStateChanged,
      signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut
    } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js';
    import {
      initializeFirestore, persistentLocalCache, persistentMultipleTabManager,
      collection, doc, addDoc, setDoc, updateDoc, deleteDoc, getDocs,
      onSnapshot, query, where, serverTimestamp, increment
    } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js';

    const FIREBASE_CONFIG = {
      apiKey: "AIzaSyCWhXRTryqXRoiRNBSFrWiB-RzmYJ-TQXM",
      authDomain: "southpass-elders-visit-tracker.firebaseapp.com",
      projectId: "southpass-elders-visit-tracker",
      storageBucket: "southpass-elders-visit-tracker.firebasestorage.app",
      messagingSenderId: "736973707480",
      appId: "1:736973707480:web:0bb5ead0d5b43d55bb9fad",
      measurementId: "G-JQKNSH8CTB"
    };
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => navigator.serviceWorker.register('/sw.js?v=1'));
    }
    const app = initializeApp(FIREBASE_CONFIG);
    const db  = initializeFirestore(app, { localCache: persistentLocalCache({ tabManager: persistentMultipleTabManager() }) });
    const auth = getAuth(app);

    /* ---------- State & helpers ---------- */
    let unsubElders=null, unsubVisits=null, unsubSchedule=null;
    let currentUser = null;
    const elders = new Map();
    const visits = [];
    const schedules = []; // users/{uid}/schedule
    let importPreviewData = null;
    let visitGroupsCache = null;
    let visitGroupsDirty = true;
    const expandedHistory = new Set();
    const historyModalState = { elderId:null, page:0 };
    const HISTORY_PAGE_SIZE = 6;

    const q = id => document.getElementById(id);
    const cleanPhone = s => (s||'').replace(/\D/g,'');
    const norm = s => (s||'').toString().trim().toLowerCase();
    const trimValue = value => (value ?? '').toString().trim();
    const formatPhoneDisplay = (value) => {
      const digits = cleanPhone(value || '');
      if (digits.length === 10) return `${digits.slice(0,3)}-${digits.slice(3,6)}-${digits.slice(6)}`;
      return digits || trimValue(value);
    };
    const defaultErrorMessage = 'Something went wrong. Please try again.';
    const toastHost = document.getElementById('toastHost');
    const confirmOverlay = document.getElementById('confirmOverlay');
    const confirmMessageEl = document.getElementById('confirmMessage');
    const confirmOkBtn = confirmOverlay?.querySelector('[data-confirm]');
    const confirmCancelBtn = confirmOverlay?.querySelector('[data-cancel]');
    const importStatusEl = q('importStatus');
    const importPreviewCard = q('importPreviewCard');
    const importPreviewSummaryEl = q('importPreviewSummary');
    const importPreviewDetailsEl = q('importPreviewDetails');
    const applyImportBtn = q('applyImportBtn');
    const downloadImportErrorsBtn = q('downloadImportErrorsBtn');
    const historyOverlay = q('historyOverlay');
    const historyModalBody = q('historyModalBody');
    const historyModalTitle = q('historyModalTitle');
    const historyModalRange = q('historyModalRange');
    const historyModalPage = q('historyModalPage');
    const historyModalCloseBtn = q('historyModalClose');
    const historyModalPrevBtn = q('historyModalPrev');
    const historyModalNextBtn = q('historyModalNext');
    let confirmResolver = null;
    let confirmActive = false;
    let confirmLastFocus = null;

    const hideToastElement = (toast) => {
      if (!toast) return;
      toast.classList.remove('show');
      const remove = () => toast.remove();
      toast.addEventListener('transitionend', remove, { once: true });
      if (toast._toastTimeout) window.clearTimeout(toast._toastTimeout);
    };
    const showToast = (message, { variant = 'info', duration = 4000, dismissible = true } = {}) => {
      if (!toastHost) return;
      const toast = document.createElement('div');
      toast.className = `toast ${variant}`;
      toast.setAttribute('role', variant === 'error' ? 'alert' : 'status');

      const text = document.createElement('span');
      text.textContent = message || '';
      toast.appendChild(text);

      if (dismissible) {
        const closeBtn = document.createElement('button');
        closeBtn.type = 'button';
        closeBtn.className = 'toast-close';
        closeBtn.setAttribute('aria-label', 'Dismiss notification');
        closeBtn.textContent = '×';
        closeBtn.addEventListener('click', () => hideToastElement(toast));
        toast.appendChild(closeBtn);
      }

      toastHost.appendChild(toast);
      requestAnimationFrame(() => toast.classList.add('show'));

      if (duration !== null) {
        toast._toastTimeout = window.setTimeout(() => hideToastElement(toast), duration);
      }
      return toast;
    };
    const showSuccessToast = (message, options = {}) => showToast(message, { variant: 'success', ...options });
    const showErrorToast = (message, options = {}) => showToast(message, { variant: 'error', ...options });
    const closeConfirm = (result) => {
      if (!confirmActive) return;
      confirmActive = false;
      confirmOverlay.classList.remove('open');
      confirmOverlay.setAttribute('aria-hidden', 'true');
      const resolver = confirmResolver;
      confirmResolver = null;
      const focusTarget = confirmLastFocus;
      confirmLastFocus = null;
      if (typeof resolver === 'function') resolver(result);
      if (focusTarget && typeof focusTarget.focus === 'function') {
        setTimeout(() => focusTarget.focus(), 0);
      }
    };
    const showConfirm = (message, { confirmText = 'Confirm', cancelText = 'Cancel', variant = 'primary' } = {}) => {
      if (!confirmOverlay || !confirmMessageEl || !confirmOkBtn || !confirmCancelBtn) {
        return Promise.resolve(window.confirm ? window.confirm(message) : true);
      }
      if (confirmActive) closeConfirm(false);

      return new Promise((resolve) => {
        confirmResolver = resolve;
        confirmActive = true;
        confirmLastFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
        confirmMessageEl.textContent = message || '';
        confirmOkBtn.textContent = confirmText;
        confirmCancelBtn.textContent = cancelText;
        confirmOkBtn.classList.remove('danger');
        if (variant === 'danger') confirmOkBtn.classList.add('danger');
        confirmOverlay.classList.add('open');
        confirmOverlay.setAttribute('aria-hidden', 'false');
        requestAnimationFrame(() => confirmOkBtn.focus());
      });
    };
    confirmOkBtn?.addEventListener('click', () => closeConfirm(true));
    confirmCancelBtn?.addEventListener('click', () => closeConfirm(false));
    confirmOverlay?.addEventListener('click', (event) => {
      if (event.target === confirmOverlay) closeConfirm(false);
    });
    confirmOverlay?.addEventListener('keydown', (event) => {
      if (!confirmActive) return;
      if (event.key === 'Escape') {
        event.preventDefault();
        closeConfirm(false);
      } else if (event.key === 'Tab') {
        const focusables = [confirmCancelBtn, confirmOkBtn].filter(Boolean);
        if (!focusables.length) return;
        const first = focusables[0];
        const last = focusables[focusables.length - 1];
        if (event.shiftKey && document.activeElement === first) {
          event.preventDefault();
          last.focus();
        } else if (!event.shiftKey && document.activeElement === last) {
          event.preventDefault();
          first.focus();
        }
      }
    });
    const setImportStatus = (message, variant = 'info') => {
      if (!importStatusEl) return;
      const text = message || '';
      importStatusEl.textContent = text;
      importStatusEl.className = `import-status ${variant}`;
      importStatusEl.style.display = text ? 'block' : 'none';
      importStatusEl.setAttribute('aria-hidden', text ? 'false' : 'true');
    };
    const clearImportPreview = () => {
      importPreviewData = null;
      if (importPreviewCard) {
        importPreviewCard.style.display = 'none';
        importPreviewCard.setAttribute('aria-hidden', 'true');
      }
      if (importPreviewSummaryEl) importPreviewSummaryEl.innerHTML = '';
      if (importPreviewDetailsEl) importPreviewDetailsEl.innerHTML = '';
      if (applyImportBtn) {
        applyImportBtn.disabled = true;
        applyImportBtn.setAttribute('aria-disabled', 'true');
        applyImportBtn.textContent = 'Apply changes';
      }
      if (downloadImportErrorsBtn) {
        downloadImportErrorsBtn.style.display = 'none';
        downloadImportErrorsBtn.setAttribute('aria-hidden', 'true');
      }
    };
    window.showToast = showToast;
    window.showSuccessToast = showSuccessToast;
    window.showErrorToast = showErrorToast;
    window.showConfirm = showConfirm;

    const runAction = (asyncFn, message = defaultErrorMessage) => async (...args) => {
      try {
        return await asyncFn(...args);
      } catch (error) {
        console.error('Action failed:', error);
        const msg = typeof message === 'function' ? message(error, ...args) : message;
        const text = msg || defaultErrorMessage;
        showToast(text, { variant: 'error' });
      }
    };
    const firestoreSafeId = (key)=>{
      const raw = (key||'').toString();
      let clean = raw.normalize('NFKD').replace(/[\u0300-\u036f]/g,'');
      clean = clean.replace(/[^A-Za-z0-9._-]+/g,'-').replace(/-+/g,'-').replace(/(^-|-$)/g,'');
      if (!clean) clean = 'id';
      clean = clean.slice(0, 100);
      clean = clean.replace(/(^-|-$)/g,'');
      if (!clean) clean = 'id';
      let hash = 0;
      for (let i = 0; i < raw.length; i++){
        hash = (hash * 31 + raw.charCodeAt(i)) >>> 0;
      }
      const suffix = hash.toString(16).padStart(8,'0');
      return `${clean}-${suffix}`;
    };
    const fmtDate = ts => { if (!ts) return '—'; const d = ts?.toDate ? ts.toDate() : new Date(ts); return d.toLocaleDateString(); };
    const asMs = t => t ? (t.toDate ? t.toDate().getTime() : new Date(t).getTime()) : 0;
    const maxDate = (a,b)=> asMs(a) >= asMs(b) ? a : b;
    const collator = new Intl.Collator(undefined, { sensitivity:'base', numeric:true });
    const escapeHtml = (value)=> String(value ?? '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
    const visitDateMs = (visit)=>{
      if (!visit) return 0;
      const raw = visit.visitDate ?? visit.date ?? visit.createdAt ?? null;
      if (!raw) return 0;
      if (typeof raw === 'number') return raw;
      if (raw instanceof Date) return raw.getTime();
      if (typeof raw === 'string') {
        const ms = Date.parse(raw);
        return isNaN(ms) ? 0 : ms;
      }
      if (typeof raw === 'object' && typeof raw.toDate === 'function') {
        const d = raw.toDate();
        return d instanceof Date && !isNaN(+d) ? d.getTime() : 0;
      }
      if (raw && typeof raw.seconds === 'number') {
        return raw.seconds * 1000;
      }
      return 0;
    };
    const visitDisplayDate = (visit)=>{
      if (!visit) return '—';
      const raw = visit.visitDate ?? visit.date ?? visit.createdAt ?? null;
      return fmtDate(raw);
    };
    const pluralize = (value, word) => `${value} ${word}${value === 1 ? '' : 's'}`;
    const buildVisitGroups = ()=>{
      const map = new Map();
      for (const v of visits){
        if (!v || !v.elderId) continue;
        if (!map.has(v.elderId)) map.set(v.elderId, []);
        map.get(v.elderId).push(v);
      }
      map.forEach(arr => arr.sort((a,b)=> visitDateMs(b) - visitDateMs(a)));
      return map;
    };
    const getVisitGroups = ()=>{
      if (!visitGroupsCache || visitGroupsDirty){
        visitGroupsCache = buildVisitGroups();
        visitGroupsDirty = false;
      }
      return visitGroupsCache;
    };
    const parseDateInputValue = (value, endOfDay = false)=>{
      if (!value) return null;
      const date = new Date(value);
      if (isNaN(+date)) return null;
      if (endOfDay) {
        date.setHours(23,59,59,999);
      } else {
        date.setHours(0,0,0,0);
      }
      return date.getTime();
    };
    const getHistoryRange = ()=>{
      const startInput = q('historyStart');
      const endInput = q('historyEnd');
      const startMs = parseDateInputValue(startInput?.value || '', false);
      const endMs = parseDateInputValue(endInput?.value || '', true);
      return { startMs, endMs };
    };
    const filterVisitsByRange = (list, range)=>{
      if (!Array.isArray(list)) return [];
      const { startMs, endMs } = range || {};
      if (!startMs && !endMs) return [...list];
      return list.filter(v => {
        const ms = visitDateMs(v);
        if (!ms) return !startMs && !endMs;
        if (startMs && ms < startMs) return false;
        if (endMs && ms > endMs) return false;
        return true;
      });
    };
    const buildRangeLabel = (range)=>{
      const { startMs, endMs } = range || {};
      if (!startMs && !endMs) return 'All time';
      const opts = { year:'numeric', month:'short', day:'numeric' };
      const startLabel = startMs ? new Date(startMs).toLocaleDateString(undefined, opts) : 'Any time';
      const endLabel = endMs ? new Date(endMs).toLocaleDateString(undefined, opts) : 'Present';
      return `${startLabel} – ${endLabel}`;
    };

    const buildImportSection = (title, count, bodyHtml, variant = '') => {
      const variantClass = variant ? ` ${variant}` : '';
      return `
        <div class="import-preview-section${variantClass}">
          <div class="import-preview-section-title">${escapeHtml(title)} (${count})</div>
          ${bodyHtml}
        </div>
      `;
    };
    const renderAddTable = (items = []) => {
      if (!items.length) return '<div class="import-preview-empty">No new elders.</div>';
      const rows = items.map(item => {
        const phoneText = item.phoneDisplay ? escapeHtml(item.phoneDisplay) : '—';
        const emailText = item.email ? escapeHtml(item.email) : '—';
        return `
          <tr>
            <td>${item.rowNumber}</td>
            <td>${escapeHtml(item.displayName)}</td>
            <td>${phoneText || '—'}</td>
            <td>${emailText || '—'}</td>
          </tr>
        `;
      }).join('');
      return `<div class="import-preview-scroll"><table><thead><tr><th>Row</th><th>Name</th><th>Phone</th><th>Email</th></tr></thead><tbody>${rows}</tbody></table></div>`;
    };
    const renderUpdateTable = (items = []) => {
      if (!items.length) return '<div class="import-preview-empty">No updates.</div>';
      const rows = items.map(item => {
        const changeHtml = item.changeDetails.map(change => {
          const label = escapeHtml(change.label);
          const value = change.value ? escapeHtml(change.value) : '—';
          return `<div><span class="muted">${label}:</span> ${value || '—'}</div>`;
        }).join('');
        return `
          <tr>
            <td>${item.rowNumber ?? '—'}</td>
            <td>${escapeHtml(item.displayName)}</td>
            <td>${changeHtml}</td>
          </tr>
        `;
      }).join('');
      return `<div class="import-preview-scroll"><table><thead><tr><th>Row</th><th>Name</th><th>Changes</th></tr></thead><tbody>${rows}</tbody></table></div>`;
    };
    const renderDeactivateTable = (items = []) => {
      if (!items.length) return '<div class="import-preview-empty">No deactivations.</div>';
      const rows = items.map(item => `
        <tr>
          <td>${escapeHtml(item.displayName)}</td>
        </tr>
      `).join('');
      return `<div class="import-preview-scroll"><table><thead><tr><th>Name</th></tr></thead><tbody>${rows}</tbody></table></div>`;
    };
    const renderErrorList = (items = []) => {
      if (!items.length) return '';
      const list = items.map(err => {
        const issues = err.issues.map(escapeHtml).join('; ');
        return `<li><strong>Row ${err.rowNumber}</strong>: ${issues}</li>`;
      }).join('');
      return `<ul class="import-error-list">${list}</ul>`;
    };
    const renderImportPreview = (preview) => {
      if (!importPreviewCard || !importPreviewSummaryEl || !importPreviewDetailsEl) return;
      importPreviewData = preview;
      const {
        adds = [],
        updates = [],
        deactivate = [],
        errors = [],
        fileName = '',
        totalRows = 0
      } = preview || {};

      const summaryParts = [
        `${adds.length} add${adds.length === 1 ? '' : 's'}`,
        `${updates.length} update${updates.length === 1 ? '' : 's'}`,
        `${deactivate.length} deactivation${deactivate.length === 1 ? '' : 's'}`
      ];
      if (errors.length) summaryParts.push(`${errors.length} error${errors.length === 1 ? '' : 's'}`);
      const summaryHtml = summaryParts.join(' • ') || 'No changes detected.';
      const titleHtml = fileName ? `File: ${escapeHtml(fileName)}` : 'Import preview';
      importPreviewSummaryEl.innerHTML = `
        <div><strong>${titleHtml}</strong></div>
        <div>${summaryHtml}</div>
        <div class="muted">Rows evaluated: ${totalRows}</div>
      `;

      const sections = [
        buildImportSection('New elders', adds.length, renderAddTable(adds)),
        buildImportSection('Updates', updates.length, renderUpdateTable(updates)),
        buildImportSection('Deactivations', deactivate.length, renderDeactivateTable(deactivate))
      ];
      if (errors.length) sections.push(buildImportSection('Issues to fix', errors.length, renderErrorList(errors), 'error'));
      importPreviewDetailsEl.innerHTML = sections.join('');

      if (importPreviewCard) {
        importPreviewCard.style.display = 'block';
        importPreviewCard.setAttribute('aria-hidden', 'false');
      }

      if (downloadImportErrorsBtn) {
        if (errors.length) {
          downloadImportErrorsBtn.style.display = 'inline-flex';
          downloadImportErrorsBtn.setAttribute('aria-hidden', 'false');
        } else {
          downloadImportErrorsBtn.style.display = 'none';
          downloadImportErrorsBtn.setAttribute('aria-hidden', 'true');
        }
      }

      if (applyImportBtn) {
        const totalActions = adds.length + updates.length + deactivate.length;
        const disabled = errors.length > 0 || totalActions === 0;
        applyImportBtn.disabled = disabled;
        applyImportBtn.setAttribute('aria-disabled', disabled ? 'true' : 'false');
        applyImportBtn.textContent = 'Apply changes';
      }
    };

    const nowMs = ()=> Date.now();
    const daysBetween = (ms)=> Math.floor((nowMs()-ms)/86400000);
    const monthsAgo = (n)=>{ const d=new Date(); d.setMonth(d.getMonth()-n); d.setHours(0,0,0,0); return d; };

    function getMonday(d=new Date()){
      const x = new Date(d); const day = x.getDay(); // 0=Sun
      const diff = x.getDate() - day + (day===0 ? -6 : 1);
      x.setDate(diff); x.setHours(0,0,0,0); return x;
    }
    function getScheduleMonday(d=new Date()){
      const base = new Date(d);
      base.setHours(0,0,0,0);
      const day = base.getDay(); // 0=Sun, 1=Mon, ...
      if (day === 0){
        base.setDate(base.getDate() + 1); // Sunday -> next Monday
      } else if (day >= 4){
        base.setDate(base.getDate() + (8 - day)); // Thu-Sat -> upcoming Monday
      }
      return getMonday(base);
    }
    function wednesdayOfWeek(weekOfDate){
      const d = weekOfDate?.toDate ? weekOfDate.toDate() : new Date(weekOfDate);
      const w = new Date(d);
      w.setDate(w.getDate()+2); // Mon + 2 = Wed
      w.setHours(19,0,0,0); // 7:00pm for flavor (optional)
      return w;
    }

    const WEEK_MS = 7*86400000;
    const WEEK_STORAGE_KEY = 'eq:selectedWeek';
    const safeStorage = {
      get(key){
        try { return window.localStorage ? localStorage.getItem(key) : null; }
        catch { return null; }
      },
      set(key, value){
        try { if (window.localStorage) localStorage.setItem(key, value); }
        catch { /* ignore */ }
      }
    };
    const canonicalWeek = (value)=>{
      const base = value?.toDate ? value.toDate() : new Date(value);
      return getMonday(base);
    };
    const loadStoredWeek = ()=>{
      const raw = safeStorage.get(WEEK_STORAGE_KEY);
      if (raw){
        const ms = Number(raw);
        if (!Number.isNaN(ms)) return canonicalWeek(new Date(ms));
      }
      return canonicalWeek(getScheduleMonday());
    };
    let selectedWeek = loadStoredWeek();
    function setSelectedWeek(date){
      selectedWeek = canonicalWeek(date);
      safeStorage.set(WEEK_STORAGE_KEY, String(selectedWeek.getTime()));
      renderNext();
    }
    function shiftSelectedWeek(delta){
      const next = new Date(selectedWeek);
      next.setDate(next.getDate() + delta*7);
      setSelectedWeek(next);
    }
    const describeWeek = (weekDate)=>{
      const start = canonicalWeek(weekDate);
      const end = new Date(start);
      end.setDate(end.getDate()+6);
      const base = canonicalWeek(getScheduleMonday());
      const diff = Math.round((start.getTime() - base.getTime()) / WEEK_MS);
      const startStr = start.toLocaleDateString(undefined, { month:'short', day:'numeric' });
      const endStr = end.toLocaleDateString(undefined, { month:'short', day:'numeric' });
      const yearStr = end.getFullYear();
      let context = '';
      let relation = 'current';
      let forLabel = '';
      if (diff === 0){ context='This week'; relation='current'; forLabel='this week'; }
      else if (diff === 1){ context='Next week'; relation='future'; forLabel='next week'; }
      else if (diff === -1){ context='Last week'; relation='past'; forLabel='last week'; }
      else if (diff > 1){ context=`In ${diff} weeks`; relation='future'; forLabel=`week of ${startStr}`; }
      else { context=`${Math.abs(diff)} weeks ago`; relation='past'; forLabel=`week of ${startStr}`; }
      return {
        start,
        end,
        range: `${startStr} – ${endStr}, ${yearStr}`,
        context,
        relation,
        forLabel
      };
    };
    function weekWednesdayLabel(weekDate){
      const wed = wednesdayOfWeek(weekDate);
      return wed.toLocaleDateString(undefined, { weekday:'short', month:'short', day:'numeric' });
    }
    const scheduleStatusInfo = (statusRaw)=>{
      const value = (statusRaw ?? 'Planned').toString().trim();
      const key = value.toLowerCase();
      if (key === 'confirmed') return { className:'status-pill confirmed', label:'Confirmed', key };
      if (key === 'visited') return { className:'status-pill visited', label:'Visited', key };
      if (key === 'planned' || key === '') return { className:'status-pill planned', label:'Planned', key:'planned' };
      return { className:'status-pill neutral', label: value || 'Planned', key };
    };
    const scheduleStatusWeight = (statusRaw)=>{
      const key = (statusRaw ?? '').toString().trim().toLowerCase();
      return ({ visited:3, confirmed:2, planned:1 }[key] || 0);
    };

    function updateAuthUI(user){
      const signedOut = !user;
      ['email','password','signinBtn','createBtn'].forEach(id => q(id).style.display = signedOut ? 'inline-block' : 'none');
      q('logoutBtn').style.display = user ? 'inline-block' : 'none';
      q('currentUser').textContent = user ? user.email : '';
      if (user){ q('email').value = ''; q('password').value = ''; }
    }

    // Text history helpers (store ISO strings in e.textHistory[])
    const texts6mInfo = (e)=>{
      const cutoff = monthsAgo(6).getTime();
      const arr = Array.isArray(e.textHistory) ? e.textHistory : [];
      let count = 0, last = null;
      for (const iso of arr){
        const t = Date.parse(iso);
        if (!isNaN(t)) {
          if (t >= cutoff) count++;
          if (!last || t > last) last = t;
        }
      }
      return { count, lastDateMs: last };
    };

    const smsBodyFor = (name) =>
      `Hey ${name}, the elders quorum presidency would love to drop in and say hi Wednesday around 7:00. Would that work for you?`;

    const userCol = path => { if (!currentUser) throw new Error('Not signed in'); return collection(db,'users',currentUser.uid,path); };

    function subscribeData(){
      unsubElders = onSnapshot(userCol('elders'), (snap)=>{
        snap.docChanges().forEach(ch=>{
          if (ch.type === 'removed') elders.delete(ch.doc.id);
          else elders.set(ch.doc.id, { id: ch.doc.id, ...ch.doc.data() });
        });
        renderAll();
      });
      unsubVisits = onSnapshot(userCol('visits'), (snap)=>{
        visits.length = 0;
        snap.forEach(d => visits.push({ id: d.id, ...d.data() }));
        visitGroupsDirty = true;
        renderAll();
      });
      unsubSchedule = onSnapshot(userCol('schedule'), (snap)=>{
        schedules.length = 0;
        snap.forEach(d => schedules.push({ id:d.id, ...d.data() }));
        renderAll();
      });
    }
    function unsubscribeData(){ if (unsubElders) unsubElders(); if (unsubVisits) unsubVisits(); if (unsubSchedule) unsubSchedule(); }

    /* ---------- Auth ---------- */
    onAuthStateChanged(auth, (user)=>{
      currentUser = user;
      updateAuthUI(user);
      if (user) subscribeData();
      else {
        unsubscribeData();
        elders.clear();
        visits.length = 0;
        schedules.length = 0;
        visitGroupsCache = null;
        visitGroupsDirty = true;
        expandedHistory.clear();
        historyModalState.elderId = null;
        closeHistoryModal();
        renderAll();
      }
    });
    window.signIn = runAction(async ()=>{
      await signInWithEmailAndPassword(auth, q('email').value.trim(), q('password').value.trim());
    }, 'Sign-in failed. Please check your credentials and try again.');
    window.create = runAction(async ()=>{
      await createUserWithEmailAndPassword(auth, q('email').value.trim(), q('password').value.trim());
    }, 'Account creation failed. Please review your details and try again.');
    window.signOut = runAction(async ()=>{
      await signOut(auth);
    }, 'Sign-out failed. Please try again.');

    /* ---------- Sorting & Search ---------- */
    let sortBy='name', sortDir='asc'; // default: first name A→Z
    window.setSort = (key)=>{
      if (sortBy === key) sortDir = (sortDir==='asc' ? 'desc' : 'asc');
      else { sortBy = key; sortDir = (key==='visited' || key==='attempts') ? 'desc' : 'asc'; }
      renderElders();
    };
    function updateSortArrows(){
      ['name','phone','visited','attempts'].forEach(k=>{
        const el = q('sort-'+k);
        if (!el) return;
        el.textContent = (sortBy===k) ? (sortDir==='asc' ? '▲' : '▼') : '';
      });
      const ss = q('sortSelect'); if (ss) ss.value = sortBy;
    }
    const filterByTokens = (e, tokens)=>{
      if (!tokens.length) return true;
      const hay = (norm(e.preferredName)+' '+norm(e.lastName)+' '+norm(e.email)+' '+norm(e.address)+' '+cleanPhone(e.phone||''));
      return tokens.every(t => hay.includes(t));
    };
    const wireSearch = () => {
      q('btnSearchElders')?.addEventListener('click', ()=>renderElders());
      q('searchElders')?.addEventListener('keydown', e=>{ if(e.key==='Enter') renderElders(); });
      q('searchElders')?.addEventListener('input', ()=>renderElders());
      q('hideInactive')?.addEventListener('change', ()=>renderElders());

      q('btnSearchNext')?.addEventListener('click', ()=>renderNext());
      q('searchNext')?.addEventListener('keydown', e=>{ if(e.key==='Enter') renderNext(); });
      q('searchNext')?.addEventListener('input', ()=>renderNext());

      q('sortSelect')?.addEventListener('change', e=>{
        sortBy = e.target.value;
        sortDir = (sortBy==='visited' || sortBy==='attempts') ? 'desc' : 'asc';
        renderElders();
      });
      const onRangeChange = ()=>{
        historyModalState.page = 0;
        renderElders();
        if (historyModalState.elderId) renderHistoryModal();
      };
      q('historyStart')?.addEventListener('change', onRangeChange);
      q('historyEnd')?.addEventListener('change', onRangeChange);
      q('historyClear')?.addEventListener('click', ()=>{
        const start = q('historyStart');
        const end = q('historyEnd');
        if (start) start.value = '';
        if (end) end.value = '';
        onRangeChange();
      });
    };
    function wireWeekNav(){
      q('weekPrevBtn')?.addEventListener('click', ()=> shiftSelectedWeek(-1));
      q('weekNextBtn')?.addEventListener('click', ()=> shiftSelectedWeek(1));
      q('weekTodayBtn')?.addEventListener('click', ()=> setSelectedWeek(getScheduleMonday()));
    }
    function wireHistoryModal(){
      historyModalCloseBtn?.addEventListener('click', ()=> closeHistoryModal());
      historyModalPrevBtn?.addEventListener('click', ()=> changeHistoryModalPage(-1));
      historyModalNextBtn?.addEventListener('click', ()=> changeHistoryModalPage(1));
      historyOverlay?.addEventListener('click', (event)=>{ if (event.target === historyOverlay) closeHistoryModal(); });
      document.addEventListener('keydown', (event)=>{
        if (event.key === 'Escape' && historyModalState.elderId) closeHistoryModal();
      });
    }

    /* ---------- Queue settings (rolling 12m + texting cooldown) ---------- */
    const SETTINGS = {
      W_DAYS:.2, W_ATTEMPTS:5, BONUS_NEVER:120,
      COOLDOWN_DAYS_TEXT:14,            // push back 14 days after a text
      PENALTY_RECENT_TEXT:-40           // strong penalty if texted within cooldown window
    };
    function needVisitThisYear(e){
      const threshold = monthsAgo(12).getTime();
      const lv = asMs(e.lastVisited);
      return !lv || lv < threshold;
    }
    function nextUpScore(e){
      if (e.active === false || e.doNotText) return -999;

      // Hold out if texted 2× within 6 months
      const tx = texts6mInfo(e);
      if (tx.count >= 2) return -999;

      const lvDays = e.lastVisited ? Math.floor((nowMs()-asMs(e.lastVisited))/86400000) : null;
      const daysScore = (lvDays === null ? SETTINGS.BONUS_NEVER : lvDays * SETTINGS.W_DAYS);
      const attemptsScore = (e.attemptsSinceLastVisit || 0) * SETTINGS.W_ATTEMPTS;

      // recent text penalty
      let recentPenalty = 0;
      if (tx.lastDateMs){
        const daysSinceText = daysBetween(tx.lastDateMs);
        if (daysSinceText < SETTINGS.COOLDOWN_DAYS_TEXT) recentPenalty = SETTINGS.PENALTY_RECENT_TEXT;
      }

      const needs = needVisitThisYear(e) ? 20 : 0; // small boost to those still needing a 12m visit
      return daysScore + attemptsScore + recentPenalty + needs;
    }

    /* ---------- Counters (rolling 12m) ---------- */
    function updateCounters(){
      const all = Array.from(elders.values());
      const active = all.filter(e=>e.active!==false);
      const threshold = monthsAgo(12).getTime();
      const needVisit = active.filter(e => !e.lastVisited || asMs(e.lastVisited) < threshold).length;
      const yr = q('yearRemaining'); if (yr) yr.textContent = `Need visit (12m): ${needVisit}`;
      const ec = q('eldersCount'); if (ec) ec.textContent = `Total: ${all.length} (${active.length} active)`;
    }

    /* ---------- UI render ---------- */
    window.showView = (name)=>{
      ['next','elders','log','import'].forEach(v=>q('view-'+v).style.display = (v===name)?'block':'none');
      if (name==='log') fillLogSelect();
      updateSortArrows(); updateCounters(); window.scrollTo({top:0, behavior:'smooth'});
    };
    function renderAll(){
      renderNext();
      renderElders();
      fillLogSelect();
      updateSortArrows();
      updateCounters();
      if (historyModalState.elderId) renderHistoryModal();
    }

    // --- Next Up (cards) + “recent texts” + schedule ---
    function renderNext(){
      // panels at top
      renderRecentTexts();
      renderSchedule();

      // Top candidates
      const grid = q('nextGrid');
      const tokens = norm(q('searchNext').value).split(/\s+/).filter(Boolean);
      const arr = Array.from(elders.values()).map(e=>({ ...e, _score: nextUpScore(e) }))
        .filter(e=> e._score > -999 && filterByTokens(e, tokens) && cleanPhone(e.phone||'').length)
        .sort((a,b)=> b._score - a._score)
        .slice(0,18);

      grid.innerHTML = arr.map(e=>{
        const lvMs = asMs(e.lastVisited);
        const ds = lvMs ? Math.floor((nowMs()-lvMs)/86400000) : null;
        const status = ds === null ? 'warn' : (ds >= 30 ? 'bad' : (ds >= 14 ? 'warn' : 'ok'));
        const diff = ds === null ? 'Never' : (ds + 'd');

        const tx = texts6mInfo(e);
        const askedTxt = tx.lastDateMs ? `Last text: ${new Date(tx.lastDateMs).toLocaleDateString()}${tx.count?` • ${tx.count}×/6m`:''}` : 'No texts yet';
        const displayName = [e.preferredName, e.lastName].filter(Boolean).join(' ').trim();
        const nameHtml = escapeHtml(displayName);
        const phoneHtml = escapeHtml(e.phone||'');
        const askedHtml = escapeHtml(askedTxt);
        const diffHtml = escapeHtml(diff);
        const name = (e.preferredName || e.lastName || 'there');

        return `
          <div class="card">
            <div style="display:flex; justify-content:space-between; align-items:center">
              <div style="font-weight:700">${nameHtml}</div>
              <span class="pill ${status}">${diffHtml}</span>
            </div>
            <div class="muted" style="margin:.25rem 0">${phoneHtml}</div>
            <div class="subtle">${askedHtml}</div>
            <div style="display:flex; gap:.5rem; margin-top:.35rem">
              <button class="btn outline" onclick="textAndTrack('${e.id}')">Text</button>
              <button class="btn" onclick="quickLogVisit('${e.id}')">Log now</button>
              <button class="btn outline" onclick="noAnswer('${e.id}')">No answer</button>
            </div>
          </div>`;
      }).join('');
    }

    function renderRecentTexts(){
      const container = q('recentTexts'); if (!container) return;
      const tenDaysAgo = Date.now() - 10*86400000;
      const items = Array.from(elders.values())
        .map(e=>({ e, lastTx: texts6mInfo(e).lastDateMs }))
        .filter(x=> x.lastTx && x.lastTx >= tenDaysAgo)
        .sort((a,b)=> b.lastTx - a.lastTx)
        .slice(0,12);
      if (!items.length){ container.innerHTML = '<div class="subtle">None yet.</div>'; return; }

      const weekMs = selectedWeek.getTime();
      const already = new Set(
        schedules
          .filter(s => asMs(s.weekOf) === weekMs)
          .map(s => s.elderId)
      );
      const confirmLabel = weekWednesdayLabel(selectedWeek);

      container.innerHTML = items.map(({e,lastTx})=>{
        const displayName = [e.preferredName, e.lastName].filter(Boolean).join(' ').trim();
        const nameHtml = escapeHtml(displayName);
        const textDateHtml = escapeHtml(new Date(lastTx).toLocaleDateString());
        const canConfirm = !already.has(e.id);
        const buttonLabel = canConfirm ? `Confirm for ${confirmLabel}` : 'Scheduled';
        return `
          <div class="row">
            <div>
              <div class="who">${nameHtml}</div>
              <div class="subtle">Texted ${textDateHtml}</div>
            </div>
            <div>
              <button class="btn ${canConfirm?'':'outline'}" ${canConfirm?`onclick="confirmVisitThisWed('${e.id}')"`:'disabled'}>
                ${escapeHtml(buttonLabel)}
              </button>
            </div>
          </div>`;
      }).join('');
    }

    function renderSchedule(){
      const container = q('thisWeek'); if (!container) return;
      const meta = describeWeek(selectedWeek);
      const weekLabelEl = q('scheduleWeekLabel'); if (weekLabelEl) weekLabelEl.textContent = meta.range;
      const weekContextEl = q('scheduleWeekContext'); if (weekContextEl) weekContextEl.textContent = meta.context;
      const todayBtn = q('weekTodayBtn'); if (todayBtn) todayBtn.disabled = (meta.relation === 'current');
      const pickBtn = q('pickWeekBtn'); if (pickBtn) pickBtn.textContent = `Pick next elder (for ${meta.forLabel})`;

      const messageLabel = meta.forLabel || 'this week';
      const weekMs = selectedWeek.getTime();
      const list = schedules
        .filter(s => asMs(s.weekOf) === weekMs)
        .sort((a,b)=>{
          const sa = (a.status||'').toString().toLowerCase();
          const sb = (b.status||'').toString().toLowerCase();
          if (sa !== sb) return sa.localeCompare(sb);
          const na = (a.elderName||'').toString();
          const nb = (b.elderName||'').toString();
          return na.localeCompare(nb, undefined, { sensitivity:'base' });
        });

      if (!list.length){
        container.innerHTML = `<div class="subtle">No visits scheduled for ${escapeHtml(messageLabel)}.</div>`;
        return;
      }

      const wedLabel = weekWednesdayLabel(selectedWeek);
      container.innerHTML = list.map(s=>{
        const e = elders.get(s.elderId);
        const rawName = e ? [e.preferredName, e.lastName].filter(Boolean).join(' ').trim() : (s.elderName||'—');
        const nameHtml = escapeHtml(rawName);
        const info = scheduleStatusInfo(s.status);
        const statusBadge = `<span class="${info.className}">${escapeHtml(info.label)}</span>`;
        const detailHtml = `<div class="subtle" style="display:flex; gap:.35rem; flex-wrap:wrap; align-items:center;">${statusBadge}<span>${escapeHtml(wedLabel)}</span></div>`;
        const actions = [];
        if (meta.relation !== 'past' && info.key !== 'confirmed' && info.key !== 'visited'){
          const confirmLabel = meta.relation === 'future' ? 'Mark confirmed' : 'Confirm';
          actions.push(`<button class="btn" onclick="setScheduleStatus('${s.id}','Confirmed')">${confirmLabel}</button>`);
        }
        if (meta.relation !== 'future' && info.key !== 'visited'){
          actions.push(`<button class="btn" onclick="markVisitedFromSchedule('${s.id}')">Mark visited</button>`);
        }
        if (meta.relation === 'future'){
          actions.push(`<button class="btn outline" onclick="shiftScheduleWeek('${s.id}', -1)">Earlier week</button>`);
        } else {
          const moveLabel = meta.relation === 'past' ? 'Reschedule forward' : 'Next week';
          actions.push(`<button class="btn outline" onclick="shiftScheduleWeek('${s.id}', 1)">${moveLabel}</button>`);
        }
        actions.push(`<button class="btn outline" onclick="unschedule('${s.id}')">Unschedule</button>`);
        return `
          <div class="row">
            <div>
              <div class="who">${nameHtml}</div>
              ${detailHtml}
            </div>
            <div class="schedule-row-actions">${actions.join('')}</div>
          </div>`;
      }).join('');
    }

    /* ---------- Directory ---------- */
    const buildHistoryPreview = (elder, visitGroups, range)=>{
      const visitsForElder = visitGroups.get(elder.id) || [];
      const filtered = filterVisitsByRange(visitsForElder, range);
      const previewVisits = filtered.slice(0, 3);
      const total = visitsForElder.length;
      const summaryBase = total
        ? (filtered.length ? `${pluralize(filtered.length, 'visit')} in range` : 'No visits in range')
        : 'No visits recorded yet.';
      const totalSuffix = total ? ` • ${pluralize(total, 'total visit')}` : '';
      const summaryText = summaryBase + totalSuffix;
      const rangeLabel = buildRangeLabel(range);
      const detailParts = [];
      if (rangeLabel) detailParts.push(rangeLabel);
      const remainder = filtered.length - previewVisits.length;
      if (remainder > 0) detailParts.push(`${pluralize(remainder, 'more visit')} in range`);
      const detailHtml = detailParts.length
        ? `<div class="history-preview-range">${detailParts.map(part => escapeHtml(part)).join(' • ')}</div>`
        : '';
      let listSection = '';
      if (previewVisits.length){
        const itemsHtml = previewVisits.map(v=>{
          const dateHtml = escapeHtml(visitDisplayDate(v));
          const outcomeHtml = escapeHtml(v.outcome || 'Visited');
          const metaParts = [];
          if (v.visitors) metaParts.push(`Visitors: ${escapeHtml(v.visitors)}`);
          const metaHtml = metaParts.length ? `<div class="history-preview-meta">${metaParts.join(' • ')}</div>` : '';
          const notesHtml = v.notes ? `<div class="history-preview-notes">${escapeHtml(v.notes)}</div>` : '';
          return `<li class="history-preview-item">
            <div class="history-preview-item-header"><span>${dateHtml}</span><span>${outcomeHtml}</span></div>
            ${metaHtml}
            ${notesHtml}
          </li>`;
        }).join('');
        listSection = `<ul class="history-preview-list">${itemsHtml}</ul>`;
      } else {
        const emptyMessage = total ? 'No visits in selected range.' : 'No visits to show yet.';
        listSection = `<div class="history-preview-empty">${escapeHtml(emptyMessage)}</div>`;
      }
      const elderIdHtml = escapeHtml(elder.id);
      return `
        <div class="history-preview">
          <div class="history-preview-header">
            <div class="history-preview-summary">${escapeHtml(summaryText)}</div>
            ${detailHtml}
          </div>
          ${listSection}
          <div class="history-preview-actions">
            <button type="button" class="btn outline" onclick="openHistoryModal(&quot;${elderIdHtml}&quot;)">Open full history</button>
          </div>
        </div>
      `;
    };

    window.renderElders = renderElders;
    function renderElders(){
      const tb = q('eldersTbody');
      const tokens = norm(q('searchElders').value).split(/\s+/).filter(Boolean);
      const hideInactive = q('hideInactive').checked;
      const visitGroups = getVisitGroups();
      const range = getHistoryRange();

      let arr = Array.from(elders.values())
        .filter(e => (!hideInactive || e.active!==false))
        .filter(e => filterByTokens(e, tokens));

      const dir = (sortDir==='asc') ? 1 : -1;
      const cmpName = (a,b)=> (collator.compare(a.preferredName||'', b.preferredName||'') || collator.compare(a.lastName||'', b.lastName||'')) * dir;
      const cmpPhone = (a,b)=> collator.compare(cleanPhone(a.phone||''), cleanPhone(b.phone||'')) * dir;
      const cmpVisited = (a,b)=> (asMs(a.lastVisited) - asMs(b.lastVisited)) * dir;
      // attempts = most recently asked first -> use lastContacted or last text time
      const lastAskedMs = (x)=> Math.max(asMs(x.lastContacted)||0, texts6mInfo(x).lastDateMs||0);
      const cmpAttempts = (a,b)=> (lastAskedMs(a) - lastAskedMs(b)) * (sortDir==='asc'?1:-1); // we force desc by default
      const cmps = { name:cmpName, phone:cmpPhone, visited:cmpVisited, attempts:cmpAttempts };
      arr.sort(cmps[sortBy] || cmpName);

      tb.innerHTML = arr.map(e=>{
        const inactive = e.active===false;
        const statusPill = inactive ? `<span class="pill gray">Inactive</span>` : `<span class="pill ok">Active</span>`;
        const archiveLabel = inactive ? 'Unarchive' : 'Archive';
        const archiveLabelHtml = escapeHtml(archiveLabel);
        const phoneDisplay = escapeHtml(e.phone||'');
        const telLink = e.phone ? `<a href="tel:+1${cleanPhone(e.phone)}">${phoneDisplay}</a>` : '';

        const tx = texts6mInfo(e);
        const askedCell = tx.lastDateMs ? `${new Date(tx.lastDateMs).toLocaleDateString()}${tx.count?` • ${tx.count}×/6m`:''}` : '—';
        const askedHtml = escapeHtml(askedCell);
        const nameHtml = escapeHtml([e.preferredName, e.lastName].filter(Boolean).join(' ').trim());
        const visitedHtml = escapeHtml(fmtDate(e.lastVisited));
        const attemptsHtml = escapeHtml(String(e.attemptsSinceLastVisit||0));
        const isExpanded = expandedHistory.has(e.id);
        const previewRowId = `history-${e.id}`;
        const historyButtonLabel = isExpanded ? 'Hide history' : 'History';
        const previewHtml = buildHistoryPreview(e, visitGroups, range);
        const expandedAttr = isExpanded ? 'true' : 'false';
        const previewRowClass = `history-preview-row${isExpanded ? ' open' : ''}`;
        const previewRowIdHtml = escapeHtml(previewRowId);
        const historyButtonLabelHtml = escapeHtml(historyButtonLabel);
        const elderIdHtml = escapeHtml(e.id);

        return `<tr class="${inactive?'inactive':''}">
          <td class="namecell" data-label="Name">${nameHtml}</td>
          <td data-label="Phone">${telLink || ''}</td>
          <td data-label="Last visited">${visitedHtml}</td>
          <td data-label="Attempts">${attemptsHtml}</td>
          <td data-label="Asked">${askedHtml}</td>
          <td data-label="Status">${statusPill}</td>
          <td class="actions" data-label="Actions">
            <button class="btn outline" onclick="textAndTrack('${e.id}')">Text</button>
            <button class="btn" onclick="quickLogVisit('${e.id}')">Log</button>
            <button class="btn outline" onclick="editElder('${e.id}')">Edit</button>
            <button class="btn outline" onclick="adjustMenu('${e.id}')">Adjust…</button>
            <button class="btn light" onclick="toggleHistoryPreview(&quot;${elderIdHtml}&quot;)" aria-expanded="${expandedAttr}" aria-controls="${previewRowIdHtml}">${historyButtonLabelHtml}</button>
            <button class="btn ${inactive?'outline danger':'danger'}" onclick="toggleArchive('${e.id}', ${inactive})">${archiveLabelHtml}</button>
          </td>
        </tr>
        <tr id="${previewRowIdHtml}" class="${previewRowClass}" data-elder="${elderIdHtml}">
          <td colspan="7">${previewHtml}</td>
        </tr>`;
      }).join('');

      updateSortArrows(); updateCounters();
    }

    window.toggleHistoryPreview = (elderId)=>{
      if (!elderId) return;
      if (expandedHistory.has(elderId)) expandedHistory.delete(elderId);
      else expandedHistory.add(elderId);
      renderElders();
    };

    window.openHistoryModal = (elderId)=>{
      if (!elderId) return;
      historyModalState.elderId = elderId;
      historyModalState.page = 0;
      renderHistoryModal();
      if (historyOverlay){
        historyOverlay.classList.add('open');
        historyOverlay.setAttribute('aria-hidden', 'false');
      }
    };

    function closeHistoryModal(){
      if (!historyOverlay) return;
      historyOverlay.classList.remove('open');
      historyOverlay.setAttribute('aria-hidden', 'true');
      historyModalState.elderId = null;
    }

    function changeHistoryModalPage(delta){
      if (!historyModalState.elderId) return;
      historyModalState.page += delta;
      if (historyModalState.page < 0) historyModalState.page = 0;
      renderHistoryModal();
    }

    function renderHistoryModal(){
      if (!historyModalState.elderId || !historyModalBody) return;
      const elder = elders.get(historyModalState.elderId);
      const visitGroups = getVisitGroups();
      const range = getHistoryRange();
      const visitsForElder = visitGroups.get(historyModalState.elderId) || [];
      const filtered = filterVisitsByRange(visitsForElder, range);
      const total = filtered.length;
      const totalPages = total ? Math.ceil(total / HISTORY_PAGE_SIZE) : 0;
      if (totalPages && historyModalState.page >= totalPages) historyModalState.page = totalPages - 1;
      if (!totalPages) historyModalState.page = 0;
      const startIndex = historyModalState.page * HISTORY_PAGE_SIZE;
      const pageItems = filtered.slice(startIndex, startIndex + HISTORY_PAGE_SIZE);

      const displayName = elder ? [elder.preferredName, elder.lastName].filter(Boolean).join(' ').trim() : '';
      if (historyModalTitle) historyModalTitle.textContent = displayName || 'Visit history';
      if (historyModalRange) historyModalRange.textContent = buildRangeLabel(range);

      if (pageItems.length){
        historyModalBody.innerHTML = pageItems.map(v=>{
          const dateHtml = escapeHtml(visitDisplayDate(v));
          const outcomeHtml = escapeHtml(v.outcome || 'Visited');
          const metaParts = [];
          if (v.visitors) metaParts.push(`Visitors: ${escapeHtml(v.visitors)}`);
          const metaHtml = metaParts.length ? `<div class="history-modal-item-meta">${metaParts.join(' • ')}</div>` : '';
          const notesHtml = v.notes ? `<div class="history-modal-item-notes">${escapeHtml(v.notes)}</div>` : '';
          return `<div class="history-modal-item">
            <div class="history-modal-item-header"><span>${dateHtml}</span><span>${outcomeHtml}</span></div>
            ${metaHtml}
            ${notesHtml}
          </div>`;
        }).join('');
      } else {
        const hasRange = !!(range.startMs || range.endMs);
        const message = hasRange ? 'No visits in selected range.' : 'No visits recorded yet.';
        historyModalBody.innerHTML = `<div class="history-preview-empty">${escapeHtml(message)}</div>`;
      }

      if (historyModalPage){
        historyModalPage.textContent = totalPages ? `Page ${historyModalState.page + 1} of ${totalPages}` : 'No visits';
      }
      if (historyModalPrevBtn){
        historyModalPrevBtn.disabled = historyModalState.page <= 0 || totalPages <= 1;
      }
      if (historyModalNextBtn){
        historyModalNextBtn.disabled = !totalPages || historyModalState.page >= totalPages - 1;
      }
    }

    function fillLogSelect(){
      const sel = q('logElderSelect');
      const arr = Array.from(elders.values()).filter(e=>e.active!==false).sort((a,b)=>collator.compare(a.lastName||'', b.lastName||''));
      sel.innerHTML = arr.map(e=>{
        const optionValue = escapeHtml(e.id);
        const optionLabel = escapeHtml([e.preferredName, e.lastName].filter(Boolean).join(' ').trim());
        return `<option value="${optionValue}">${optionLabel}</option>`;
      }).join('');
      if (!q('logDate').value) q('logDate').valueAsDate = new Date();
    }

    /* ---------- Actions ---------- */
    window.textAndTrack = runAction(async (elderId)=>{
      const e = elders.get(elderId);
      if (!e || !e.phone) return;

      // prune to 6m and append now
      const cutoffMs = monthsAgo(6).getTime();
      const hist = Array.isArray(e.textHistory) ? e.textHistory.filter(iso => Date.parse(iso) >= cutoffMs) : [];
      hist.push(new Date().toISOString());

      const ref = doc(db, 'users', currentUser.uid, 'elders', elderId);
      await updateDoc(ref, {
        lastTexted: serverTimestamp(),
        lastContacted: serverTimestamp(),
        textHistory: hist,
        attemptsSinceLastVisit: increment(1)
      });

      const rawName = (e.preferredName ? e.preferredName.trim() : '')
        || (e.lastName ? e.lastName.trim() : '')
        || 'there';
      const firstName = rawName.split(/\s+/)[0] || 'there';
      const smsUrl = `sms:+1${cleanPhone(e.phone)}?&body=${encodeURIComponent(smsBodyFor(firstName))}`;
      setTimeout(()=>{ window.location.href = smsUrl; }, 100);
    }, 'Unable to send that text. Please check your connection and try again.');

    window.saveVisit = runAction(async ()=>{
      const elderId = q('logElderSelect').value;
      const dateStr = q('logDate').value;
      const outcome = q('logOutcome').value;
      const visitors = q('logVisitors').value.trim();
      const notes = q('logNotes').value.trim();
      if (!elderId || !dateStr) {
        showErrorToast('Pick elder and date.');
        return;
      }
      const visit = { elderId, visitDate: dateStr, outcome, visitors, notes, createdAt: new Date() };
      await addDoc(userCol('visits'), visit);
      const ref = doc(db, 'users', currentUser.uid, 'elders', elderId);
      const isVisited = (outcome === 'Visited' || outcome === 'Scheduled');
      const update = {
        lastContacted: serverTimestamp(),
        attemptsSinceLastVisit: isVisited ? 0 : increment(1)
      };
      if (isVisited) {
        update.lastVisited = new Date(dateStr);
      }
      await updateDoc(ref, update);
      q('logNotes').value='';
      showSuccessToast('Saved visit.');
    }, 'Unable to save the visit. Please try again.');

    window.quickLogVisit = runAction(async (elderId)=>{
      const ref = doc(db, 'users', currentUser.uid, 'elders', elderId);
      await updateDoc(ref, { lastVisited: serverTimestamp(), lastContacted: serverTimestamp(), attemptsSinceLastVisit: 0 });
      await addDoc(userCol('visits'), {
        elderId, visitDate: new Date().toISOString().slice(0,10),
        outcome: 'Visited', visitors: 'Presidency', notes:'(Quick log)', createdAt: new Date()
      });
    }, 'Unable to quick-log that visit. Please try again.');

    window.noAnswer = runAction(async (elderId)=>{
      const ref = doc(db, 'users', currentUser.uid, 'elders', elderId);
      await updateDoc(ref, { lastContacted: serverTimestamp(), attemptsSinceLastVisit: increment(1) });
      await addDoc(userCol('visits'), {
        elderId, visitDate: new Date().toISOString().slice(0,10),
        outcome: 'No answer', visitors: 'Presidency', notes:'', createdAt: new Date()
      });
    }, 'Unable to record the no-answer attempt. Please try again.');

    window.addElderPrompt = runAction(async ()=>{
      const name = prompt('Preferred name and last name (e.g., John Doe)?');
      if (!name) return;
      const phone = prompt('Phone (optional)') || '';
      const [preferredName, ...rest] = name.split(' ');
      const lastName = rest.join(' ');
      await addDoc(userCol('elders'), {
        preferredName, lastName, phone, active: true, firstSeen: new Date(),
        attemptsSinceLastVisit: 0, doNotText: false
      });
    }, 'Unable to add that elder. Please try again.');

    window.editElder = runAction(async (id)=>{
      const e = elders.get(id); if (!e) return;
      const name = prompt('Edit name', `${e.preferredName||''} ${e.lastName||''}`) || '';
      const phone = prompt('Edit phone', e.phone||'') || '';
      const doNotText = await showConfirm('Mark as Do Not Text?', {
        confirmText: 'Yes',
        cancelText: 'No'
      });
      const [preferredName, ...rest] = name.split(' ');
      const lastName = rest.join(' ');
      const ref = doc(db, 'users', currentUser.uid, 'elders', id);
      await updateDoc(ref, { preferredName, lastName, phone, doNotText });
    }, 'Unable to update that elder. Please try again.');

    window.toggleArchive = runAction(async (id, isInactive)=>{
      const ref = doc(db, 'users', currentUser.uid, 'elders', id);
      if (isInactive) {
        await updateDoc(ref, { active: true });
      } else {
        const confirmed = await showConfirm('Archive this elder (set inactive)?', {
          confirmText: 'Archive',
          cancelText: 'Keep active',
          variant: 'danger'
        });
        if (!confirmed) return;
        await updateDoc(ref, { active: false });
      }
    }, 'Unable to change the archive state. Please try again.');

    // Adjust menu: reset visit or remove last ask (with double-check)
    window.adjustMenu = runAction(async (id)=>{
      const e = elders.get(id); if (!e) return;
      const choice = prompt(
        'Type 1 or 2 (or Cancel):\n' +
        '1) Reset last visit (treat as not visited)\n' +
        '2) Remove last ask (decrement attempts & remove latest text log)\n' +
        'Cancel) anything else'
      );
      if (choice === '1'){
        const confirmed = await showConfirm('Are you sure you want to reset LAST VISIT for this elder?', {
          confirmText: 'Reset visit',
          cancelText: 'Cancel',
          variant: 'danger'
        });
        if (!confirmed) return;
        const ref = doc(db, 'users', currentUser.uid, 'elders', id);
        await updateDoc(ref, {
          lastVisited: null,
          lastContacted: serverTimestamp(),
          attemptsSinceLastVisit: increment(1) // bump—still need to ask again
        });
        showSuccessToast('Last visit reset.');
      } else if (choice === '2'){
        const confirmed = await showConfirm('Are you sure you want to remove the MOST RECENT ASK?', {
          confirmText: 'Remove ask',
          cancelText: 'Cancel',
          variant: 'danger'
        });
        if (!confirmed) return;
        const hist = Array.isArray(e.textHistory) ? [...e.textHistory] : [];
        if (hist.length) hist.pop();
        const newAttempts = Math.max(0, (e.attemptsSinceLastVisit||0)-1);
        const ref = doc(db, 'users', currentUser.uid, 'elders', id);
        await updateDoc(ref, {
          textHistory: hist,
          attemptsSinceLastVisit: newAttempts,
          lastTexted: null // UI will compute from history anyway
        });
        showSuccessToast('Most recent ask removed.');
      } else {
        // no-op
      }
    }, 'Unable to adjust that record. Please try again.');

    /* ---------- Keys (no householdId) ---------- */
    const keyFromDoc = (e) => [ cleanPhone(e.phone||''), norm(e.email||''), norm((e.preferredName||'')+'|'+(e.lastName||'')) ].join('|');
    const keyFromRow = (r) => [ cleanPhone(r.Phone||r.phone||''), norm(r.Email||r.email||''), norm((r.PreferredName||r.FirstName||'')+'|'+(r.LastName||'')) ].join('|');

    /* ---------- Export backup / CSV ---------- */
    window.exportBackup = runAction(async ()=>{
      const [es, vs] = await Promise.all([ getDocs(userCol('elders')), getDocs(userCol('visits')) ]);
      const data = {
        elders: es.docs.map(d=>({id:d.id,...d.data()})),
        visits: vs.docs.map(d=>({id:d.id,...d.data()}))
      };
      const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob); a.download = 'eq-visit-backup.json'; a.click(); URL.revokeObjectURL(a.href);
    }, 'Unable to export the backup. Please try again.');
    window.exportCsv = runAction(async ()=>{
      const snap = await getDocs(userCol('elders'));
      const rows = snap.docs.map(d=>{
        const e = { id:d.id, ...d.data() };
        const toIso = (t)=> t ? (t.toDate ? t.toDate().toISOString().slice(0,10) : new Date(t).toISOString().slice(0,10)) : '';
        // last text from lastTexted or textHistory
        let lastTx = e.lastTexted ? (e.lastTexted.toDate ? e.lastTexted.toDate() : new Date(e.lastTexted)) : null;
        if ((!lastTx || isNaN(+lastTx)) && Array.isArray(e.textHistory) && e.textHistory.length){
          const ms = Math.max(...e.textHistory.map(x=>Date.parse(x)||0)); if (ms>0) lastTx = new Date(ms);
        }
        return {
          PreferredName: e.preferredName || '', LastName: e.lastName || '',
          Phone: e.phone || '', Email: e.email || '', Address: e.address || '',
          DoNotText: e.doNotText ? 'Yes' : 'No', Active: e.active!==false ? 'Yes' : 'No',
          LastVisited: toIso(e.lastVisited), LastContacted: toIso(e.lastContacted),
          LastTexted: lastTx ? lastTx.toISOString().slice(0,10) : '',
          Attempts: e.attemptsSinceLastVisit || 0, Id: e.id
        };
      });
      const csv = Papa.unparse(rows);
      const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob); a.download = 'elders_export.csv'; a.click(); URL.revokeObjectURL(a.href);
    }, 'Unable to export the CSV. Please try again.');

    /* ---------- Import (idempotent) ---------- */
    function parseCsv(file){
      return new Promise((resolve, reject)=>{
        Papa.parse(file, { header:true, skipEmptyLines:true,
          complete: (res)=>resolve(res.data), error: reject });
      });
    }
    async function importCsv(){
      clearImportPreview();
      const input = q('csvFile');
      const file = input?.files?.[0];
      if (!file) {
        setImportStatus('Choose a CSV file to preview.', 'warning');
        return;
      }
      if (!currentUser?.uid) {
        setImportStatus('Sign in to preview and apply imports.', 'error');
        return;
      }
      setImportStatus('Processing CSV…', 'info');
      try {
        const rows = await parseCsv(file);
        const snap = await getDocs(userCol('elders'));
        const existingByKey = new Map();
        snap.forEach(d=>{
          const data = { id:d.id, ...d.data() };
          existingByKey.set(keyFromDoc(data), data);
        });

        const seenKeys = new Set();
        const keyCounts = new Map();
        const adds = [];
        const updates = [];
        const deactivate = [];
        const errors = [];

        rows.forEach((row, index)=>{
          const raw = row || {};
          const rowNumber = index + 2;
          const preferredName = trimValue(raw.PreferredName ?? raw.FirstName ?? '');
          const lastName = trimValue(raw.LastName ?? '');
          const email = trimValue(raw.Email ?? raw.email ?? '');
          const address = trimValue(raw.Address ?? raw.address ?? '');
          const rawPhone = trimValue(raw.Phone ?? raw.phone ?? '');
          const phoneDigits = cleanPhone(rawPhone);
          const doNotText = ((raw.DoNotText ?? raw.do_not_text ?? '').toString().toLowerCase().startsWith('y'));
          const key = keyFromRow(raw);
          const issues = [];

          const priorCount = keyCounts.get(key) || 0;
          keyCounts.set(key, priorCount + 1);
          if (priorCount > 0) issues.push('Duplicate entry in this file.');
          if (!preferredName) issues.push('Preferred/first name is required.');
          if (!lastName) issues.push('Last name is required.');
          if (!phoneDigits) {
            issues.push('Phone number is required.');
          } else if (phoneDigits.length !== 10) {
            issues.push('Phone number must have 10 digits.');
          }

          if (issues.length) {
            errors.push({ rowNumber, issues, row: raw });
            if (key) seenKeys.add(key);
            return;
          }

          seenKeys.add(key);
          const payload = {
            preferredName,
            lastName,
            phone: phoneDigits,
            email,
            address,
            doNotText,
            active: true
          };
          const displayName = `${preferredName} ${lastName}`.trim();
          const match = existingByKey.get(key);
          if (match){
            const changes = {};
            const changeDetails = [];
            if (trimValue(match.preferredName) !== payload.preferredName){
              changes.preferredName = payload.preferredName;
              changeDetails.push({ label:'Preferred name', value: payload.preferredName || '—' });
            }
            if (trimValue(match.lastName) !== payload.lastName){
              changes.lastName = payload.lastName;
              changeDetails.push({ label:'Last name', value: payload.lastName || '—' });
            }
            if (cleanPhone(match.phone || '') !== payload.phone){
              changes.phone = payload.phone;
              changeDetails.push({ label:'Phone', value: formatPhoneDisplay(payload.phone) || '—' });
            }
            if (trimValue(match.email) !== payload.email){
              changes.email = payload.email;
              changeDetails.push({ label:'Email', value: payload.email || '—' });
            }
            if (trimValue(match.address) !== payload.address){
              changes.address = payload.address;
              changeDetails.push({ label:'Address', value: payload.address || '—' });
            }
            if (!!match.doNotText !== !!payload.doNotText){
              changes.doNotText = payload.doNotText;
              changeDetails.push({ label:'Do not text', value: payload.doNotText ? 'Yes' : 'No' });
            }
            if (match.active === false){
              changes.active = true;
              changeDetails.push({ label:'Status', value: 'Active' });
            }
            if (Object.keys(changes).length){
              updates.push({ id: match.id, key, displayName, rowNumber, changes, changeDetails });
            }
          } else {
            const newId = firestoreSafeId(key);
            adds.push({
              id: newId,
              key,
              displayName,
              rowNumber,
              payload,
              phoneDisplay: formatPhoneDisplay(payload.phone),
              email,
              address
            });
          }
        });

        for (const [key, record] of existingByKey.entries()){
          if (!seenKeys.has(key) && record.active !== false){
            const name = `${trimValue(record.preferredName)} ${trimValue(record.lastName)}`.trim();
            const fallbackPhone = formatPhoneDisplay(record.phone);
            const fallbackEmail = trimValue(record.email);
            const label = name || fallbackPhone || fallbackEmail || record.id;
            deactivate.push({ id: record.id, key, displayName: label });
          }
        }

        const preview = {
          adds,
          updates,
          deactivate,
          errors,
          fileName: file.name,
          totalRows: rows.length
        };
        renderImportPreview(preview);

        if (errors.length){
          setImportStatus(`Found ${errors.length} issue${errors.length === 1 ? '' : 's'} that must be fixed before applying changes.`, 'error');
        } else {
          const totalActions = adds.length + updates.length + deactivate.length;
          if (totalActions){
            setImportStatus(`Preview ready. Review and confirm ${totalActions} change${totalActions === 1 ? '' : 's'} before applying.`, 'info');
          } else {
            setImportStatus('No changes detected in the import file.', 'success');
          }
        }
      } catch (error) {
        console.error('Import preview failed:', error);
        clearImportPreview();
        setImportStatus('Unable to process that CSV. Please verify the file and try again.', 'error');
      }
    }
    async function applyImportChanges(){
      if (!importPreviewData){
        setImportStatus('Generate a preview before applying changes.', 'warning');
        return;
      }
      const { adds = [], updates = [], deactivate = [], errors = [] } = importPreviewData;
      if (errors.length){
        setImportStatus('Resolve the errors listed in the preview before applying changes.', 'error');
        return;
      }
      const totalActions = adds.length + updates.length + deactivate.length;
      if (!totalActions){
        setImportStatus('No changes are pending from the preview.', 'info');
        return;
      }
      if (!currentUser?.uid){
        setImportStatus('Sign in to apply import changes.', 'error');
        return;
      }
      const confirmed = await showConfirm(`Apply ${totalActions} change${totalActions === 1 ? '' : 's'} from this import?`, {
        confirmText: 'Apply changes',
        cancelText: 'Cancel'
      });
      if (!confirmed){
        setImportStatus('Import cancelled.', 'warning');
        return;
      }
      const applyBtn = applyImportBtn;
      const originalText = applyBtn?.textContent;
      if (applyBtn){
        applyBtn.disabled = true;
        applyBtn.setAttribute('aria-disabled', 'true');
        applyBtn.textContent = 'Applying…';
      }
      try {
        setImportStatus('Applying changes…', 'info');
        const uid = currentUser.uid;
        for (const add of adds){
          await setDoc(doc(db,'users',uid,'elders',add.id), { ...add.payload, firstSeen: new Date(), attemptsSinceLastVisit: 0 }, { merge:true });
        }
        for (const update of updates){
          await updateDoc(doc(db,'users',uid,'elders',update.id), update.changes);
        }
        for (const record of deactivate){
          await updateDoc(doc(db,'users',uid,'elders',record.id), { active:false });
        }
        setImportStatus(`Applied ${totalActions} change${totalActions === 1 ? '' : 's'} successfully.`, 'success');
        clearImportPreview();
        if (applyBtn){
          applyBtn.disabled = true;
          applyBtn.setAttribute('aria-disabled', 'true');
        }
        const fileInput = q('csvFile');
        if (fileInput) fileInput.value = '';
      } catch (error) {
        console.error('Apply import failed:', error);
        setImportStatus('Unable to apply the import changes. Please try again.', 'error');
      } finally {
        if (applyBtn){
          applyBtn.textContent = originalText || 'Apply changes';
          const preview = importPreviewData;
          if (preview){
            const pending = (preview.adds?.length || 0) + (preview.updates?.length || 0) + (preview.deactivate?.length || 0);
            const hasErrors = preview.errors?.length;
            const disabled = hasErrors || !pending;
            applyBtn.disabled = !!disabled;
            applyBtn.setAttribute('aria-disabled', disabled ? 'true' : 'false');
          } else {
            applyBtn.disabled = true;
            applyBtn.setAttribute('aria-disabled', 'true');
          }
        }
      }
    }
    function downloadImportErrors(){
      const errors = importPreviewData?.errors || [];
      if (!errors.length){
        setImportStatus('No error report available for download.', 'warning');
        return;
      }
      const rows = errors.map(err => {
        const row = err.row || {};
        return {
          RowNumber: err.rowNumber,
          Issues: err.issues.join('; '),
          PreferredName: row.PreferredName ?? row.FirstName ?? '',
          LastName: row.LastName ?? '',
          Phone: row.Phone ?? row.phone ?? '',
          Email: row.Email ?? row.email ?? '',
          Address: row.Address ?? row.address ?? ''
        };
      });
      const csv = Papa.unparse(rows);
      const blob = new Blob([csv], { type:'text/csv;charset=utf-8;' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'import_errors.csv';
      a.click();
      URL.revokeObjectURL(a.href);
      setImportStatus('Downloaded error report.', 'info');
    }
    window.importCsv = importCsv;
    window.applyImportChanges = applyImportChanges;
    window.downloadImportErrors = downloadImportErrors;

    /* ---------- Fix duplicates ---------- */
    window.fixDuplicates = runAction(async ()=>{
      const confirmed = await showConfirm('Merge duplicates (preserve visit history)?', {
        confirmText: 'Merge duplicates',
        cancelText: 'Cancel',
        variant: 'danger'
      });
      if (!confirmed) return;
      const uid = currentUser?.uid; if (!uid) { showErrorToast('Sign in first.'); return; }

      const es = await getDocs(userCol('elders'));
      const items = es.docs.map(d=>({ id:d.id, ...d.data() }));

      const find=(p,x)=> (p[x]===x ? x : (p[x]=find(p,p[x])));
      const unite=(p,a,b)=>{ a=find(p,a); b=find(p,b); if(a!==b) p[b]=a; };

      const parent = {}; items.forEach(e=>parent[e.id]=e.id);
      const mapify = getter => {
        const m = new Map();
        items.forEach(e=>{ const k=getter(e); if(!k) return; if(!m.has(k)) m.set(k,[]); m.get(k).push(e.id); });
        return m;
      };
      const clean = x=>x||'';
      const byPhone = mapify(e=>cleanPhone(clean(e.phone)));
      const byEmail = mapify(e=>norm(clean(e.email)));
      const byName  = mapify(e=>norm((clean(e.preferredName))+'|'+(clean(e.lastName))));
      [byPhone,byEmail,byName].forEach(map=>{ map.forEach(ids=>{ for(let i=1;i<ids.length;i++) unite(parent, ids[0], ids[i]); }); });

      const clusters = new Map();
      items.forEach(e=>{ const r=find(parent,e.id); if(!clusters.has(r)) clusters.set(r,[]); clusters.get(r).push(e); });

      let mergedCount = 0;
      const score = e => (e.email?1:0)+(e.phone?1:0)+(e.address?1:0)+(e.active!==false?1:0)+(e.lastVisited?2:0)+(e.lastContacted?1:0)+((e.attemptsSinceLastVisit||0)>0?1:0);
      const keeperScheduleCache = new Map();
      const statusWeight = status => ({ Visited:3, Confirmed:2, Planned:1 }[status] || 0);
      const ensureKeeperSchedules = async (keeperId)=>{
        if (keeperScheduleCache.has(keeperId)) return keeperScheduleCache.get(keeperId);
        const snap = await getDocs(query(userCol('schedule'), where('elderId','==', keeperId)));
        const arr = snap.docs.map(d=>({ id:d.id, data:d.data() }));
        keeperScheduleCache.set(keeperId, arr);
        return arr;
      };

      for (const [, group] of clusters){
        if (group.length <= 1) continue;

        let keep = group[0];
        for (const g of group.slice(1)){
          const sg = score(g), sk = score(keep);
          if (sg>sk || (sg===sk && asMs(g.lastVisited)>asMs(keep.lastVisited))) keep = g;
        }

        for (const dup of group){
          if (dup.id === keep.id) continue;

          const vs = await getDocs(query(userCol('visits'), where('elderId','==', dup.id)));
          for (const v of vs.docs){ await updateDoc(doc(db,'users',uid,'visits',v.id), { elderId: keep.id }); }

          const dupSchedules = await getDocs(query(userCol('schedule'), where('elderId','==', dup.id)));
          const keeperSchedules = await ensureKeeperSchedules(keep.id);
          for (const sched of dupSchedules.docs){
            const schedData = sched.data();
            const weekMs = asMs(schedData.weekOf);
            const existing = keeperSchedules.find(s=> asMs(s.data.weekOf) === weekMs);
            const keeperName = ((keep.preferredName||'')+' '+(keep.lastName||'')).trim();

            if (existing){
              const updates = {};
              if (statusWeight(schedData.status) > statusWeight(existing.data.status)) updates.status = schedData.status;
              const existingName = (existing.data.elderName||'').trim();
              if (keeperName && existingName !== keeperName) updates.elderName = keeperName;
              if (schedData.createdAt && (!existing.data.createdAt || asMs(schedData.createdAt) < asMs(existing.data.createdAt))) updates.createdAt = schedData.createdAt;
              for (const [key, value] of Object.entries(schedData)){
                if (['elderId','elderName','weekOf','status','createdAt'].includes(key)) continue;
                const current = existing.data[key];
                if ((current === undefined || current === null || current === '') && value !== undefined && value !== null && value !== '') updates[key] = value;
              }
              if (Object.keys(updates).length){
                await updateDoc(doc(db,'users',uid,'schedule',existing.id), updates);
                Object.assign(existing.data, updates);
              }
              await deleteDoc(doc(db,'users',uid,'schedule',sched.id));
            } else {
              const updates = { elderId: keep.id };
              if (keeperName && (schedData.elderName||'').trim() !== keeperName) updates.elderName = keeperName;
              if (Object.keys(updates).length){
                await updateDoc(doc(db,'users',uid,'schedule',sched.id), updates);
                Object.assign(schedData, updates);
              }
              keeperSchedules.push({ id: sched.id, data: schedData });
            }
          }

          const merged = {
            preferredName: keep.preferredName || dup.preferredName || '',
            lastName: keep.lastName || dup.lastName || '',
            phone: keep.phone || dup.phone || '',
            email: keep.email || dup.email || '',
            address: keep.address || dup.address || '',
            lastVisited: maxDate(keep.lastVisited, dup.lastVisited) || keep.lastVisited || dup.lastVisited || null,
            lastContacted: maxDate(keep.lastContacted, dup.lastContacted) || keep.lastContacted || dup.lastContacted || null,
            attemptsSinceLastVisit: Math.max(keep.attemptsSinceLastVisit||0, dup.attemptsSinceLastVisit||0),
            doNotText: !!(keep.doNotText || dup.doNotText),
            // Keep the merged elder active if any source record is still active.
            active: (keep.active!==false || dup.active!==false)
          };
          await updateDoc(doc(db,'users',uid,'elders',keep.id), merged);
          await deleteDoc(doc(db,'users',uid,'elders',dup.id));
          mergedCount++;
        }
      }
      showSuccessToast(`Fixed ${mergedCount} duplicate record(s).`);
    }, 'Unable to fix duplicates right now. Please try again.');

    /* ---------- Scheduling helpers ---------- */
    function shiftWeekDate(weekOf, deltaWeeks){
      const base = canonicalWeek(weekOf);
      const next = new Date(base);
      next.setDate(next.getDate() + Number(deltaWeeks||0)*7);
      return next;
    }
    async function moveScheduleByWeeks(scheduleId, deltaWeeks){
      const s = schedules.find(x=>x.id===scheduleId);
      if (!s) return null;
      const e = elders.get(s.elderId);
      const targetMonday = shiftWeekDate(s.weekOf, deltaWeeks);
      const targetMs = targetMonday.getTime();
      const existing = schedules.find(x=> x.elderId===s.elderId && asMs(x.weekOf) === targetMs);
      const nameValue = (e ? ((e.preferredName||'')+' '+(e.lastName||'')) : (s.elderName||'')).trim();

      if (existing){
        const updates = { weekOf: targetMonday };
        const existingName = (existing.elderName||'').trim();
        if (nameValue && existingName !== nameValue) updates.elderName = nameValue;
        if (scheduleStatusWeight(existing.status) < scheduleStatusWeight('Planned')) updates.status = 'Planned';
        await updateDoc(doc(db,'users',currentUser.uid,'schedule',existing.id), updates);
      } else {
        const payload = { weekOf: targetMonday, elderId: s.elderId, status:'Planned', createdAt: new Date() };
        if (nameValue) payload.elderName = nameValue;
        await addDoc(userCol('schedule'), payload);
      }

      await deleteDoc(doc(db,'users',currentUser.uid,'schedule',scheduleId));
      return targetMonday;
    }
    window.setScheduleStatus = runAction(async (scheduleId, status)=>{
      const ref = doc(db,'users',currentUser.uid,'schedule',scheduleId);
      const normalized = (status ?? '').toString() || 'Planned';
      await updateDoc(ref, { status: normalized });
      const info = scheduleStatusInfo(normalized);
      const sched = schedules.find(x=>x.id===scheduleId);
      const label = sched ? weekWednesdayLabel(sched.weekOf) : 'that week';
      showSuccessToast(`${info.label} for ${label}.`);
    }, 'Unable to update that schedule right now. Please try again.');
    window.confirmVisitThisWed = runAction(async (elderId)=>{
      const e = elders.get(elderId); if (!e) return;
      const monday = canonicalWeek(selectedWeek);
      const weekMs = monday.getTime();
      const existing = schedules.find(s => s.elderId === elderId && asMs(s.weekOf) === weekMs);
      const elderName = ((e.preferredName||'')+' '+(e.lastName||'')).trim();
      const wedLabel = weekWednesdayLabel(monday);
      if (existing){
        const currentStatus = (existing.status||'').toString().toLowerCase();
        if (currentStatus === 'visited'){
          showToast(`Already marked visited for ${wedLabel}.`, { variant:'info' });
          return;
        }
        const updates = {};
        if (elderName && (existing.elderName||'').trim() !== elderName) updates.elderName = elderName;
        if (currentStatus !== 'confirmed') updates.status = 'Confirmed';
        if (Object.keys(updates).length){
          await updateDoc(doc(db,'users',currentUser.uid,'schedule',existing.id), updates);
        }
      } else {
        await addDoc(userCol('schedule'), {
          weekOf: monday,
          elderId,
          elderName,
          createdAt: new Date(),
          status: 'Confirmed'
        });
      }
      showSuccessToast(`Confirmed for ${wedLabel}.`);
    }, 'Unable to confirm that visit. Please try again.');
    window.unschedule = runAction(async (scheduleId)=>{
      const s = schedules.find(x=>x.id===scheduleId);
      const e = s ? elders.get(s.elderId) : null;
      const name = (e ? ((e.preferredName||'')+' '+(e.lastName||'')) : (s?.elderName||''))?.trim() || 'this elder';
      const label = s ? weekWednesdayLabel(s.weekOf) : 'this plan';
      const confirmed = await showConfirm(`Remove ${name} from the plan for ${label}?`, {
        confirmText: 'Remove',
        cancelText: 'Keep'
      });
      if (!confirmed) return;
      await deleteDoc(doc(db,'users',currentUser.uid,'schedule',scheduleId));
    }, 'Unable to unschedule that visit. Please try again.');
    window.shiftScheduleWeek = runAction(async (scheduleId, delta)=>{
      const s = schedules.find(x=>x.id===scheduleId);
      if (!s) return;
      const e = elders.get(s.elderId);
      const displayName = (e ? (e.preferredName||e.lastName) : null) || (s.elderName||'this elder');
      const deltaNumber = Number(delta) || 0;
      const direction = deltaNumber < 0 ? 'the previous' : 'next';
      const targetMondayPreview = shiftWeekDate(s.weekOf, deltaNumber);
      const targetLabel = weekWednesdayLabel(targetMondayPreview);
      const confirmedMove = await showConfirm(`Move ${displayName} to the ${direction} week (${targetLabel})?`, {
        confirmText: 'Move',
        cancelText: 'Cancel'
      });
      if (!confirmedMove) return;
      const target = await moveScheduleByWeeks(scheduleId, deltaNumber);
      if (!target) return;
      showSuccessToast(`Moved to ${weekWednesdayLabel(target)}.`);
    }, 'Unable to move that visit. Please try again.');
    window.markVisitedFromSchedule = runAction(async (scheduleId)=>{
      const s = schedules.find(x=>x.id===scheduleId); if (!s) return;
      const e = elders.get(s.elderId); if (!e) return;
      const confirmedVisit = await showConfirm(`Mark ${e.preferredName||e.lastName||'this elder'} as visited (this Wed)?`, {
        confirmText: 'Mark visited',
        cancelText: 'Cancel',
        variant: 'danger'
      });
      if (!confirmedVisit) return;
      const wed = wednesdayOfWeek(s.weekOf);
      // update elder
      await updateDoc(doc(db,'users',currentUser.uid,'elders',s.elderId), {
        lastVisited: wed,
        attemptsSinceLastVisit: 0,
        lastContacted: serverTimestamp()
      });
      // add visit record
      await addDoc(userCol('visits'), {
        elderId: s.elderId, visitDate: wed.toISOString().slice(0,10),
        outcome: 'Visited', visitors: 'Presidency', notes:'(Auto from schedule)', createdAt: new Date()
      });
      // remove from schedule list now that it is complete
      await deleteDoc(doc(db,'users',currentUser.uid,'schedule',scheduleId));
      showSuccessToast('Marked visited.');
    }, 'Unable to mark that visit right now. Please try again.');

    window.pickThisWeek = runAction(async ()=>{
      const weekMs = selectedWeek.getTime();
      const already = new Set(
        schedules
          .filter(s => asMs(s.weekOf) === weekMs)
          .map(s => s.elderId)
      );
      const arr = Array.from(elders.values())
        .filter(e => e.active!==false && !e.doNotText && cleanPhone(e.phone||'').length)
        .filter(e => !already.has(e.id));
      arr.forEach(e => e._score = nextUpScore(e));
      arr.sort((a,b)=> b._score - a._score);
      if (!arr.length) {
        showToast('No eligible elders for this week.', { variant: 'info' });
        return;
      }
      const chosen = arr[0];
      const monday = canonicalWeek(selectedWeek);
      const elderName = ((chosen.preferredName||'')+' '+(chosen.lastName||'')).trim();
      await addDoc(userCol('schedule'), { weekOf:monday, elderId:chosen.id, elderName, createdAt:new Date(), status:'Planned' });
      showSuccessToast(`Picked ${elderName || 'an elder'} for ${weekWednesdayLabel(selectedWeek)}.`);
    }, 'Unable to pick an elder this week. Please try again.');

    /* ---------- Start ---------- */
    window.showView('next');
    wireWeekNav();
    wireSearch();
    wireHistoryModal();
  </script>

  <!-- Firestore Security Rules
  rules_version = '2';
  service cloud.firestore {
    match /databases/{database}/documents {
      match /users/{uid}/{collection}/{docId} {
        allow read, write: if request.auth != null && request.auth.uid == uid;
      }
    }
  }
  -->
</body>
</html>
